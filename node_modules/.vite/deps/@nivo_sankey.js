import {
  require_jsx_runtime
} from "./chunk-B2GAMZSM.js";
import {
  Accent_default,
  Blues_default,
  BrBG_default,
  BuGn_default,
  BuPu_default,
  Dark2_default,
  GnBu_default,
  Greens_default,
  Greys_default,
  OrRd_default,
  Oranges_default,
  PRGn_default,
  Paired_default,
  Pastel1_default,
  Pastel2_default,
  PiYG_default,
  PuBuGn_default,
  PuBu_default,
  PuOr_default,
  PuRd_default,
  Purples_default,
  RdBu_default,
  RdGy_default,
  RdPu_default,
  RdYlBu_default,
  RdYlGn_default,
  Reds_default,
  Set1_default,
  Set2_default,
  Set3_default,
  Spectral_default,
  YlGnBu_default,
  YlGn_default,
  YlOrBr_default,
  YlOrRd_default,
  category10_default,
  cividis_default,
  cool,
  cubehelix,
  cubehelixLong,
  cubehelix_default,
  format,
  inferno,
  magma,
  max,
  min,
  ordinal,
  plasma,
  rainbow_default,
  require_prop_types,
  rgb,
  rgbBasis,
  scheme,
  scheme10,
  scheme11,
  scheme12,
  scheme13,
  scheme14,
  scheme15,
  scheme16,
  scheme17,
  scheme18,
  scheme19,
  scheme2,
  scheme20,
  scheme21,
  scheme22,
  scheme23,
  scheme24,
  scheme25,
  scheme26,
  scheme27,
  scheme3,
  scheme4,
  scheme5,
  scheme6,
  scheme7,
  scheme8,
  scheme9,
  sinebow_default,
  string_default,
  sum,
  timeFormat,
  turbo_default,
  viridis_default,
  warm
} from "./chunk-FT6H3BRH.js";
import {
  require_react_dom
} from "./chunk-QUFT4VOS.js";
import {
  require_react
} from "./chunk-WHMHD7EJ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module.exports = freeGlobal;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module.exports = root;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports, module) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module.exports = Symbol2;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
      try {
        value2[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e5) {
      }
      var result = nativeObjectToString.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag] = tag;
        } else {
          delete value2[symToStringTag];
        }
      }
      return result;
    }
    module.exports = getRawTag;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports, module) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    module.exports = objectToString;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    module.exports = baseGetTag;
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports, module) {
    function isObject(value2) {
      var type = typeof value2;
      return value2 != null && (type == "object" || type == "function");
    }
    module.exports = isObject;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value2) {
      if (!isObject(value2)) {
        return false;
      }
      var tag = baseGetTag(value2);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module.exports = isFunction;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports, module) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module.exports = coreJsData;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports, module) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module.exports = isMasked;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports, module) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e5) {
        }
        try {
          return func + "";
        } catch (e5) {
        }
      }
      return "";
    }
    module.exports = toSource;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports, module) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value2) {
      if (!isObject(value2) || isMasked(value2)) {
        return false;
      }
      var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value2));
    }
    module.exports = baseIsNative;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports, module) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module.exports = getValue;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports, module) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value2 = getValue(object, key);
      return baseIsNative(value2) ? value2 : void 0;
    }
    module.exports = getNative;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports, module) {
    var getNative = require_getNative();
    var nativeCreate = getNative(Object, "create");
    module.exports = nativeCreate;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    module.exports = hashClear;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports, module) {
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = hashDelete;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    module.exports = hashGet;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    module.exports = hashHas;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports, module) {
    var nativeCreate = require_nativeCreate();
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key, value2) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED : value2;
      return this;
    }
    module.exports = hashSet;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports, module) {
    var hashClear = require_hashClear();
    var hashDelete = require_hashDelete();
    var hashGet = require_hashGet();
    var hashHas = require_hashHas();
    var hashSet = require_hashSet();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    module.exports = Hash;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports, module) {
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    module.exports = listCacheClear;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports, module) {
    function eq(value2, other) {
      return value2 === other || value2 !== value2 && other !== other;
    }
    module.exports = eq;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports, module) {
    var eq = require_eq();
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module.exports = assocIndexOf;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    module.exports = listCacheDelete;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    module.exports = listCacheGet;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    module.exports = listCacheHas;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports, module) {
    var assocIndexOf = require_assocIndexOf();
    function listCacheSet(key, value2) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value2]);
      } else {
        data[index][1] = value2;
      }
      return this;
    }
    module.exports = listCacheSet;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports, module) {
    var listCacheClear = require_listCacheClear();
    var listCacheDelete = require_listCacheDelete();
    var listCacheGet = require_listCacheGet();
    var listCacheHas = require_listCacheHas();
    var listCacheSet = require_listCacheSet();
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    module.exports = ListCache;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module.exports = Map2;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports, module) {
    var Hash = require_Hash();
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    module.exports = mapCacheClear;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports, module) {
    function isKeyable(value2) {
      var type = typeof value2;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
    }
    module.exports = isKeyable;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports, module) {
    var isKeyable = require_isKeyable();
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module.exports = getMapData;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module.exports = mapCacheDelete;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    module.exports = mapCacheGet;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    module.exports = mapCacheHas;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports, module) {
    var getMapData = require_getMapData();
    function mapCacheSet(key, value2) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value2);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    module.exports = mapCacheSet;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports, module) {
    var mapCacheClear = require_mapCacheClear();
    var mapCacheDelete = require_mapCacheDelete();
    var mapCacheGet = require_mapCacheGet();
    var mapCacheHas = require_mapCacheHas();
    var mapCacheSet = require_mapCacheSet();
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    module.exports = MapCache;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports, module) {
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value2) {
      this.__data__.set(value2, HASH_UNDEFINED);
      return this;
    }
    module.exports = setCacheAdd;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports, module) {
    function setCacheHas(value2) {
      return this.__data__.has(value2);
    }
    module.exports = setCacheHas;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports, module) {
    var MapCache = require_MapCache();
    var setCacheAdd = require_setCacheAdd();
    var setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    module.exports = SetCache;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value2) {
      return value2 !== value2;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value2, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value2) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value2, fromIndex) {
      return value2 === value2 ? strictIndexOf(array, value2, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value2) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value2, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value2, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value2, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports, module) {
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    module.exports = cacheHas;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module.exports = Set2;
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop2() {
    }
    module.exports = noop2;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports, module) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value2) {
        result[++index] = value2;
      });
      return result;
    }
    module.exports = setToArray;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop2 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value2 = array[index], computed = iteratee ? iteratee(value2) : value2;
          value2 = comparator || value2 !== 0 ? value2 : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value2);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value2);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module.exports = uniq;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports, module) {
    var ListCache = require_ListCache();
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    module.exports = stackClear;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports, module) {
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module.exports = stackDelete;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports, module) {
    function stackGet(key) {
      return this.__data__.get(key);
    }
    module.exports = stackGet;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports, module) {
    function stackHas(key) {
      return this.__data__.has(key);
    }
    module.exports = stackHas;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports, module) {
    var ListCache = require_ListCache();
    var Map2 = require_Map();
    var MapCache = require_MapCache();
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value2) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value2]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value2);
      this.size = data.size;
      return this;
    }
    module.exports = stackSet;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports, module) {
    var ListCache = require_ListCache();
    var stackClear = require_stackClear();
    var stackDelete = require_stackDelete();
    var stackGet = require_stackGet();
    var stackHas = require_stackHas();
    var stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    module.exports = Stack;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports, module) {
    var getNative = require_getNative();
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e5) {
      }
    }();
    module.exports = defineProperty;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports, module) {
    var defineProperty = require_defineProperty();
    function baseAssignValue(object, key, value2) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value2,
          "writable": true
        });
      } else {
        object[key] = value2;
      }
    }
    module.exports = baseAssignValue;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value2) {
      if (value2 !== void 0 && !eq(object[key], value2) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports, module) {
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    module.exports = createBaseFor;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports, module) {
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    module.exports = baseFor;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports, module) {
    var root = require_root();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports, module) {
    var root = require_root();
    var Uint8Array = root.Uint8Array;
    module.exports = Uint8Array;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports, module) {
    var Uint8Array = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }
    module.exports = cloneArrayBuffer;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module.exports = cloneTypedArray;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports, module) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module.exports = copyArray;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports, module) {
    var isObject = require_isObject();
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    module.exports = baseCreate;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports, module) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module.exports = overArg;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports, module) {
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    module.exports = getPrototype;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports, module) {
    var objectProto = Object.prototype;
    function isPrototype(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value2 === proto;
    }
    module.exports = isPrototype;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports, module) {
    var baseCreate = require_baseCreate();
    var getPrototype = require_getPrototype();
    var isPrototype = require_isPrototype();
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    module.exports = initCloneObject;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports, module) {
    function isObjectLike(value2) {
      return value2 != null && typeof value2 == "object";
    }
    module.exports = isObjectLike;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value2) {
      return isObjectLike(value2) && baseGetTag(value2) == argsTag;
    }
    module.exports = baseIsArguments;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports, module) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
    };
    module.exports = isArguments;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports, module) {
    var isArray = Array.isArray;
    module.exports = isArray;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
    }
    module.exports = isLength;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports, module) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value2) {
      return value2 != null && isLength(value2.length) && !isFunction(value2);
    }
    module.exports = isArrayLike;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value2) {
      return isObjectLike(value2) && isArrayLike(value2);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports, module) {
    function stubFalse() {
      return false;
    }
    module.exports = stubFalse;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports, module) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var getPrototype = require_getPrototype();
    var isObjectLike = require_isObjectLike();
    var objectTag = "[object Object]";
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value2) {
      if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
        return false;
      }
      var proto = getPrototype(value2);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module.exports = isPlainObject;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value2) {
      return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
    }
    module.exports = baseIsTypedArray;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports, module) {
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    module.exports = baseUnary;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports, module) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e5) {
      }
    }();
    module.exports = nodeUtil;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports, module) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module.exports = isTypedArray;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function assignValue(object, key, value2) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    module.exports = assignValue;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports, module) {
    var assignValue = require_assignValue();
    var baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    module.exports = copyObject;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports, module) {
    function baseTimes(n4, iteratee) {
      var index = -1, result = Array(n4);
      while (++index < n4) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module.exports = baseTimes;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value2, length) {
      var type = typeof value2;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
    }
    module.exports = isIndex;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports, module) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function arrayLikeKeys(value2, inherited) {
      var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
      for (var key in value2) {
        if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = arrayLikeKeys;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports, module) {
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = nativeKeysIn;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports, module) {
    var isObject = require_isObject();
    var isPrototype = require_isPrototype();
    var nativeKeysIn = require_nativeKeysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeysIn;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeysIn = require_baseKeysIn();
    var isArrayLike = require_isArrayLike();
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = keysIn;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value2) {
      return copyObject(value2, keysIn(value2));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction = require_isFunction();
    var isObject = require_isObject();
    var isPlainObject = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports, module) {
    function identity(value2) {
      return value2;
    }
    module.exports = identity;
  }
});

// node_modules/lodash/_apply.js
var require_apply = __commonJS({
  "node_modules/lodash/_apply.js"(exports, module) {
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    module.exports = apply;
  }
});

// node_modules/lodash/_overRest.js
var require_overRest = __commonJS({
  "node_modules/lodash/_overRest.js"(exports, module) {
    var apply = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start2, transform) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start2 + index];
        }
        index = -1;
        var otherArgs = Array(start2 + 1);
        while (++index < start2) {
          otherArgs[index] = args[index];
        }
        otherArgs[start2] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    module.exports = overRest;
  }
});

// node_modules/lodash/constant.js
var require_constant = __commonJS({
  "node_modules/lodash/constant.js"(exports, module) {
    function constant2(value2) {
      return function() {
        return value2;
      };
    }
    module.exports = constant2;
  }
});

// node_modules/lodash/_baseSetToString.js
var require_baseSetToString = __commonJS({
  "node_modules/lodash/_baseSetToString.js"(exports, module) {
    var constant2 = require_constant();
    var defineProperty = require_defineProperty();
    var identity = require_identity();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant2(string),
        "writable": true
      });
    };
    module.exports = baseSetToString;
  }
});

// node_modules/lodash/_shortOut.js
var require_shortOut = __commonJS({
  "node_modules/lodash/_shortOut.js"(exports, module) {
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    module.exports = shortOut;
  }
});

// node_modules/lodash/_setToString.js
var require_setToString = __commonJS({
  "node_modules/lodash/_setToString.js"(exports, module) {
    var baseSetToString = require_baseSetToString();
    var shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    module.exports = setToString;
  }
});

// node_modules/lodash/_baseRest.js
var require_baseRest = __commonJS({
  "node_modules/lodash/_baseRest.js"(exports, module) {
    var identity = require_identity();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function baseRest(func, start2) {
      return setToString(overRest(func, start2, identity), func + "");
    }
    module.exports = baseRest;
  }
});

// node_modules/lodash/_isIterateeCall.js
var require_isIterateeCall = __commonJS({
  "node_modules/lodash/_isIterateeCall.js"(exports, module) {
    var eq = require_eq();
    var isArrayLike = require_isArrayLike();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    function isIterateeCall(value2, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value2);
      }
      return false;
    }
    module.exports = isIterateeCall;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports, module) {
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    function isKey(value2, object) {
      if (isArray(value2)) {
        return false;
      }
      var type = typeof value2;
      if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
        return true;
      }
      return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
    }
    module.exports = isKey;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports, module) {
    var MapCache = require_MapCache();
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    module.exports = memoize;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports, module) {
    var memoize = require_memoize();
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module.exports = memoizeCapped;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports, module) {
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    module.exports = stringToPath;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isArray(value2)) {
        return arrayMap(value2, baseToString) + "";
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports, module) {
    var isArray = require_isArray();
    var isKey = require_isKey();
    var stringToPath = require_stringToPath();
    var toString = require_toString();
    function castPath(value2, object) {
      if (isArray(value2)) {
        return value2;
      }
      return isKey(value2, object) ? [value2] : stringToPath(toString(value2));
    }
    module.exports = castPath;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports, module) {
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    function toKey(value2) {
      if (typeof value2 == "string" || isSymbol(value2)) {
        return value2;
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    module.exports = toKey;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports, module) {
    var castPath = require_castPath();
    var toKey = require_toKey();
    function baseGet(object, path2) {
      path2 = castPath(path2, object);
      var index = 0, length = path2.length;
      while (object != null && index < length) {
        object = object[toKey(path2[index++])];
      }
      return index && index == length ? object : void 0;
    }
    module.exports = baseGet;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports, module) {
    var baseGet = require_baseGet();
    function get(object, path2, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path2);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  }
});

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path2, value2, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path2[index]), newValue = value2;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    var baseSet = require_baseSet();
    function set(object, path2, value2) {
      return object == null ? object : baseSet(object, path2, value2);
    }
    module.exports = set;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value2) {
      return typeof value2 == "string" || !isArray(value2) && isObjectLike(value2) && baseGetTag(value2) == stringTag;
    }
    module.exports = isString;
  }
});

// node_modules/lodash/last.js
var require_last = __commonJS({
  "node_modules/lodash/last.js"(exports, module) {
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    module.exports = last;
  }
});

// node_modules/lodash/_baseDifference.js
var require_baseDifference = __commonJS({
  "node_modules/lodash/_baseDifference.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var arrayMap = require_arrayMap();
    var baseUnary = require_baseUnary();
    var cacheHas = require_cacheHas();
    var LARGE_ARRAY_SIZE = 200;
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value2 = array[index], computed = iteratee == null ? value2 : iteratee(value2);
          value2 = comparator || value2 !== 0 ? value2 : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value2);
          } else if (!includes(values, computed, comparator)) {
            result.push(value2);
          }
        }
      return result;
    }
    module.exports = baseDifference;
  }
});

// node_modules/lodash/without.js
var require_without = __commonJS({
  "node_modules/lodash/without.js"(exports, module) {
    var baseDifference = require_baseDifference();
    var baseRest = require_baseRest();
    var isArrayLikeObject = require_isArrayLikeObject();
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, values) : [];
    });
    module.exports = without;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path2 = paths[index], value2 = baseGet(object, path2);
        if (predicate(value2, path2)) {
          baseSet(result, castPath(path2, object), value2);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports, module) {
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    module.exports = baseHasIn;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports, module) {
    var castPath = require_castPath();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isIndex = require_isIndex();
    var isLength = require_isLength();
    var toKey = require_toKey();
    function hasPath(object, path2, hasFunc) {
      path2 = castPath(path2, object);
      var index = -1, length = path2.length, result = false;
      while (++index < length) {
        var key = toKey(path2[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    module.exports = hasPath;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports, module) {
    var baseHasIn = require_baseHasIn();
    var hasPath = require_hasPath();
    function hasIn(object, path2) {
      return object != null && hasPath(object, path2, baseHasIn);
    }
    module.exports = hasIn;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value2, path2) {
        return hasIn(object, path2);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports, module) {
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    module.exports = arrayPush;
  }
});

// node_modules/lodash/_isFlattenable.js
var require_isFlattenable = __commonJS({
  "node_modules/lodash/_isFlattenable.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value2) {
      return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
    }
    module.exports = isFlattenable;
  }
});

// node_modules/lodash/_baseFlatten.js
var require_baseFlatten = __commonJS({
  "node_modules/lodash/_baseFlatten.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isFlattenable = require_isFlattenable();
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value2 = array[index];
        if (depth > 0 && predicate(value2)) {
          if (depth > 1) {
            baseFlatten(value2, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value2);
          }
        } else if (!isStrict) {
          result[result.length] = value2;
        }
      }
      return result;
    }
    module.exports = baseFlatten;
  }
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS({
  "node_modules/lodash/flatten.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }
    module.exports = flatten;
  }
});

// node_modules/lodash/_flatRest.js
var require_flatRest = __commonJS({
  "node_modules/lodash/_flatRest.js"(exports, module) {
    var flatten = require_flatten();
    var overRest = require_overRest();
    var setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten), func + "");
    }
    module.exports = flatRest;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports, module) {
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    module.exports = arraySome;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports, module) {
    var SetCache = require_SetCache();
    var arraySome = require_arraySome();
    var cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    module.exports = equalArrays;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports, module) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value2, key) {
        result[++index] = [key, value2];
      });
      return result;
    }
    module.exports = mapToArray;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var Uint8Array = require_Uint8Array();
    var eq = require_eq();
    var equalArrays = require_equalArrays();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    module.exports = equalByTag;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var isArray = require_isArray();
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    module.exports = baseGetAllKeys;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports, module) {
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value2 = array[index];
        if (predicate(value2, index, array)) {
          result[resIndex++] = value2;
        }
      }
      return result;
    }
    module.exports = arrayFilter;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports, module) {
    function stubArray() {
      return [];
    }
    module.exports = stubArray;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports, module) {
    var arrayFilter = require_arrayFilter();
    var stubArray = require_stubArray();
    var objectProto = Object.prototype;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    module.exports = getSymbols;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports, module) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module.exports = nativeKeys;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports, module) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module.exports = baseKeys;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports, module) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module.exports = keys;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbols = require_getSymbols();
    var keys = require_keys();
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    module.exports = getAllKeys;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports, module) {
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    module.exports = equalObjects;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module.exports = DataView;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module.exports = Promise2;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports, module) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap2 = getNative(root, "WeakMap");
    module.exports = WeakMap2;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports, module) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap2 = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value2) {
        var result = baseGetTag(value2), Ctor = result == objectTag ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module.exports = getTag;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports, module) {
    var Stack = require_Stack();
    var equalArrays = require_equalArrays();
    var equalByTag = require_equalByTag();
    var equalObjects = require_equalObjects();
    var getTag = require_getTag();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isTypedArray = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    module.exports = baseIsEqualDeep;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports, module) {
    var baseIsEqualDeep = require_baseIsEqualDeep();
    var isObjectLike = require_isObjectLike();
    function baseIsEqual(value2, other, bitmask, customizer, stack) {
      if (value2 === other) {
        return true;
      }
      if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
        return value2 !== value2 && other !== other;
      }
      return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
    }
    module.exports = baseIsEqual;
  }
});

// node_modules/lodash/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/lodash/isEqual.js"(exports, module) {
    var baseIsEqual = require_baseIsEqual();
    function isEqual2(value2, other) {
      return baseIsEqual(value2, other);
    }
    module.exports = isEqual2;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports, module) {
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    module.exports = arrayEach;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports, module) {
    var copyObject = require_copyObject();
    var keys = require_keys();
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    module.exports = baseAssign;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    module.exports = baseAssignIn;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbols = require_getSymbols();
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    module.exports = copySymbols;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports, module) {
    var arrayPush = require_arrayPush();
    var getPrototype = require_getPrototype();
    var getSymbols = require_getSymbols();
    var stubArray = require_stubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    module.exports = getSymbolsIn;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports, module) {
    var copyObject = require_copyObject();
    var getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    module.exports = copySymbolsIn;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports, module) {
    var baseGetAllKeys = require_baseGetAllKeys();
    var getSymbolsIn = require_getSymbolsIn();
    var keysIn = require_keysIn();
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    module.exports = getAllKeysIn;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports, module) {
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    module.exports = initCloneArray;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module.exports = cloneDataView;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports, module) {
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module.exports = cloneRegExp;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    module.exports = cloneSymbol;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports, module) {
    var cloneArrayBuffer = require_cloneArrayBuffer();
    var cloneDataView = require_cloneDataView();
    var cloneRegExp = require_cloneRegExp();
    var cloneSymbol = require_cloneSymbol();
    var cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    module.exports = initCloneByTag;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value2) {
      return isObjectLike(value2) && getTag(value2) == mapTag;
    }
    module.exports = baseIsMap;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports, module) {
    var baseIsMap = require_baseIsMap();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    module.exports = isMap;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports, module) {
    var getTag = require_getTag();
    var isObjectLike = require_isObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value2) {
      return isObjectLike(value2) && getTag(value2) == setTag;
    }
    module.exports = baseIsSet;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports, module) {
    var baseIsSet = require_baseIsSet();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    module.exports = isSet;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports, module) {
    var Stack = require_Stack();
    var arrayEach = require_arrayEach();
    var assignValue = require_assignValue();
    var baseAssign = require_baseAssign();
    var baseAssignIn = require_baseAssignIn();
    var cloneBuffer = require_cloneBuffer();
    var copyArray = require_copyArray();
    var copySymbols = require_copySymbols();
    var copySymbolsIn = require_copySymbolsIn();
    var getAllKeys = require_getAllKeys();
    var getAllKeysIn = require_getAllKeysIn();
    var getTag = require_getTag();
    var initCloneArray = require_initCloneArray();
    var initCloneByTag = require_initCloneByTag();
    var initCloneObject = require_initCloneObject();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isMap = require_isMap();
    var isObject = require_isObject();
    var isSet = require_isSet();
    var keys = require_keys();
    var keysIn = require_keysIn();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_FLAT_FLAG = 2;
    var CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value2, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object ? customizer(value2, key, object, stack) : customizer(value2);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value2)) {
        return value2;
      }
      var isArr = isArray(value2);
      if (isArr) {
        result = initCloneArray(value2);
        if (!isDeep) {
          return copyArray(value2, result);
        }
      } else {
        var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value2)) {
          return cloneBuffer(value2, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value2);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value2 : {};
          }
          result = initCloneByTag(value2, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value2);
      if (stacked) {
        return stacked;
      }
      stack.set(value2, result);
      if (isSet(value2)) {
        value2.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
        });
      } else if (isMap(value2)) {
        value2.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value2);
      arrayEach(props || value2, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value2[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
      });
      return result;
    }
    module.exports = baseClone;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value2) {
      return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep;
  }
});

// node_modules/@nivo/sankey/dist/nivo-sankey.es.js
var import_react19 = __toESM(require_react());
var import_uniq = __toESM(require_uniq());

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_react16 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());

// node_modules/@nivo/tooltip/dist/nivo-tooltip.es.js
var import_react15 = __toESM(require_react());

// node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  const time = raf.now() + ms;
  const cancel = () => {
    const i4 = timeouts.findIndex((t5) => t5.cancel == cancel);
    if (~i4)
      timeouts.splice(i4, 1);
    pendingCount -= ~i4 ? 1 : 0;
  };
  const timeout = { time, handler, cancel };
  timeouts.splice(findTimeout(time), 0, timeout);
  pendingCount += 1;
  start();
  return timeout;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t5) => t5.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  () => {
  }
);
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn(
      "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
    );
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  const prevTs = ts;
  ts = raf.now();
  const count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t5) => t5.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values, each2) {
  values.forEach((value2) => {
    try {
      each2(value2);
    } catch (e5) {
      raf.catch(e5);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var globals_exports = {};
__export(globals_exports, {
  assign: () => assign,
  colors: () => colors,
  createStringInterpolator: () => createStringInterpolator,
  skipAnimation: () => skipAnimation,
  to: () => to,
  willAdvance: () => willAdvance
});
function noop() {
}
var defineHidden = (obj, key, value2) => Object.defineProperty(obj, key, { value: value2, writable: true, configurable: true });
var is = {
  arr: Array.isArray,
  obj: (a4) => !!a4 && a4.constructor.name === "Object",
  fun: (a4) => typeof a4 === "function",
  str: (a4) => typeof a4 === "string",
  num: (a4) => typeof a4 === "number",
  und: (a4) => a4 === void 0
};
function isEqual(a4, b3) {
  if (is.arr(a4)) {
    if (!is.arr(b3) || a4.length !== b3.length)
      return false;
    for (let i4 = 0; i4 < a4.length; i4++) {
      if (a4[i4] !== b3[i4])
        return false;
    }
    return true;
  }
  return a4 === b3;
}
var each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx2) {
  if (is.arr(obj)) {
    for (let i4 = 0; i4 < obj.length; i4++) {
      fn.call(ctx2, obj[i4], `${i4}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a4) => is.und(a4) ? [] : is.arr(a4) ? a4 : [a4];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator;
var to;
var colors = null;
var skipAnimation = false;
var willAdvance = noop;
var assign = (globals) => {
  if (globals.to)
    to = globals.to;
  if (globals.now)
    raf.now = globals.now;
  if (globals.colors !== void 0)
    colors = globals.colors;
  if (globals.skipAnimation != null)
    skipAnimation = globals.skipAnimation;
  if (globals.createStringInterpolator)
    createStringInterpolator = globals.createStringInterpolator;
  if (globals.requestAnimationFrame)
    raf.use(globals.requestAnimationFrame);
  if (globals.batchedUpdates)
    raf.batchedUpdates = globals.batchedUpdates;
  if (globals.willAdvance)
    willAdvance = globals.willAdvance;
  if (globals.frameLoop)
    raf.frameLoop = globals.frameLoop;
};
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  /** Advance the given animation on every frame until idle. */
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  /** Advance all animations by the given time. */
  advance,
  /** Call this when an animation's priority changes. */
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  /**
   * Clear all animations. For testing purposes.
   *
   * ☠️ Never call this from within the frameloop.
   */
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation))
    startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(
    findIndex(currentFrame, (other) => other.priority > animation.priority),
    0,
    animation
  );
}
function advance(dt2) {
  const nextFrame = prevFrame;
  for (let i4 = 0; i4 < currentFrame.length; i4++) {
    const animation = currentFrame[i4];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt2);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index = arr.findIndex(test);
  return index < 0 ? arr.length : index;
}
var clamp = (min3, max3, v4) => Math.min(Math.max(v4, min3), max3);
var colors2 = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb2 = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp(
  "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
);
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color))
    return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors && colors[color] !== void 0) {
    return colors[color];
  }
  if (match = rgb2.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    255) >>> // a
    0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | // r
    parse255(match[2]) << 16 | // g
    parse255(match[3]) << 8 | // b
    parse1(match[4])) >>> // a
    0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      "ff",
      // a
      16
    ) >>> 0;
  }
  if (match = hex8.exec(color))
    return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(
      match[1] + match[1] + // r
      match[2] + match[2] + // g
      match[3] + match[3] + // b
      match[4] + match[4],
      // a
      16
    ) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | 255) >>> // a
    0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(
      parse360(match[1]),
      // h
      parsePercentage(match[2]),
      // s
      parsePercentage(match[3])
      // l
    ) | parse1(match[4])) >>> // a
    0;
  }
  return null;
}
function hue2rgb(p3, q2, t5) {
  if (t5 < 0)
    t5 += 1;
  if (t5 > 1)
    t5 -= 1;
  if (t5 < 1 / 6)
    return p3 + (q2 - p3) * 6 * t5;
  if (t5 < 1 / 2)
    return q2;
  if (t5 < 2 / 3)
    return p3 + (q2 - p3) * (2 / 3 - t5) * 6;
  return p3;
}
function hslToRgb(h2, s4, l3) {
  const q2 = l3 < 0.5 ? l3 * (1 + s4) : l3 + s4 - l3 * s4;
  const p3 = 2 * l3 - q2;
  const r4 = hue2rgb(p3, q2, h2 + 1 / 3);
  const g3 = hue2rgb(p3, q2, h2);
  const b3 = hue2rgb(p3, q2, h2 - 1 / 3);
  return Math.round(r4 * 255) << 24 | Math.round(g3 * 255) << 16 | Math.round(b3 * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0)
    return 0;
  if (int > 255)
    return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0)
    return 0;
  if (num > 1)
    return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0)
    return 0;
  if (int > 100)
    return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null)
    return input;
  int32Color = int32Color || 0;
  const r4 = (int32Color & 4278190080) >>> 24;
  const g3 = (int32Color & 16711680) >>> 16;
  const b3 = (int32Color & 65280) >>> 8;
  const a4 = (int32Color & 255) / 255;
  return `rgba(${r4}, ${g3}, ${b3}, ${a4})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t5) => t5);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(
      input,
      inputRange[range2],
      inputRange[range2 + 1],
      outputRange[range2],
      outputRange[range2 + 1],
      easing,
      extrapolateLeft,
      extrapolateRight,
      config2.map
    );
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity")
      return result;
    else if (extrapolateLeft === "clamp")
      result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity")
      return result;
    else if (extrapolateRight === "clamp")
      result = inputMax;
  }
  if (outputMin === outputMax)
    return outputMin;
  if (inputMin === inputMax)
    return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity)
    result = -result;
  else if (inputMax === Infinity)
    result = result - inputMin;
  else
    result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity)
    result = -result;
  else if (outputMax === Infinity)
    result = result + outputMin;
  else
    result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i4 = 1; i4 < inputRange.length - 1; ++i4)
    if (inputRange[i4] >= input)
      break;
  return i4 - 1;
}
var steps = (steps2, direction = "end") => (progress2) => {
  progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
  const expanded = progress2 * steps2;
  const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
  return clamp(0, 1, rounded / steps2);
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x5) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x5 < 1 / d1) {
    return n1 * x5 * x5;
  } else if (x5 < 2 / d1) {
    return n1 * (x5 -= 1.5 / d1) * x5 + 0.75;
  } else if (x5 < 2.5 / d1) {
    return n1 * (x5 -= 2.25 / d1) * x5 + 0.9375;
  } else {
    return n1 * (x5 -= 2.625 / d1) * x5 + 0.984375;
  }
};
var easings = {
  linear: (x5) => x5,
  easeInQuad: (x5) => x5 * x5,
  easeOutQuad: (x5) => 1 - (1 - x5) * (1 - x5),
  easeInOutQuad: (x5) => x5 < 0.5 ? 2 * x5 * x5 : 1 - Math.pow(-2 * x5 + 2, 2) / 2,
  easeInCubic: (x5) => x5 * x5 * x5,
  easeOutCubic: (x5) => 1 - Math.pow(1 - x5, 3),
  easeInOutCubic: (x5) => x5 < 0.5 ? 4 * x5 * x5 * x5 : 1 - Math.pow(-2 * x5 + 2, 3) / 2,
  easeInQuart: (x5) => x5 * x5 * x5 * x5,
  easeOutQuart: (x5) => 1 - Math.pow(1 - x5, 4),
  easeInOutQuart: (x5) => x5 < 0.5 ? 8 * x5 * x5 * x5 * x5 : 1 - Math.pow(-2 * x5 + 2, 4) / 2,
  easeInQuint: (x5) => x5 * x5 * x5 * x5 * x5,
  easeOutQuint: (x5) => 1 - Math.pow(1 - x5, 5),
  easeInOutQuint: (x5) => x5 < 0.5 ? 16 * x5 * x5 * x5 * x5 * x5 : 1 - Math.pow(-2 * x5 + 2, 5) / 2,
  easeInSine: (x5) => 1 - Math.cos(x5 * Math.PI / 2),
  easeOutSine: (x5) => Math.sin(x5 * Math.PI / 2),
  easeInOutSine: (x5) => -(Math.cos(Math.PI * x5) - 1) / 2,
  easeInExpo: (x5) => x5 === 0 ? 0 : Math.pow(2, 10 * x5 - 10),
  easeOutExpo: (x5) => x5 === 1 ? 1 : 1 - Math.pow(2, -10 * x5),
  easeInOutExpo: (x5) => x5 === 0 ? 0 : x5 === 1 ? 1 : x5 < 0.5 ? Math.pow(2, 20 * x5 - 10) / 2 : (2 - Math.pow(2, -20 * x5 + 10)) / 2,
  easeInCirc: (x5) => 1 - Math.sqrt(1 - Math.pow(x5, 2)),
  easeOutCirc: (x5) => Math.sqrt(1 - Math.pow(x5 - 1, 2)),
  easeInOutCirc: (x5) => x5 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x5, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x5 + 2, 2)) + 1) / 2,
  easeInBack: (x5) => c3 * x5 * x5 * x5 - c1 * x5 * x5,
  easeOutBack: (x5) => 1 + c3 * Math.pow(x5 - 1, 3) + c1 * Math.pow(x5 - 1, 2),
  easeInOutBack: (x5) => x5 < 0.5 ? Math.pow(2 * x5, 2) * ((c2 + 1) * 2 * x5 - c2) / 2 : (Math.pow(2 * x5 - 2, 2) * ((c2 + 1) * (x5 * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x5) => x5 === 0 ? 0 : x5 === 1 ? 1 : -Math.pow(2, 10 * x5 - 10) * Math.sin((x5 * 10 - 10.75) * c4),
  easeOutElastic: (x5) => x5 === 0 ? 0 : x5 === 1 ? 1 : Math.pow(2, -10 * x5) * Math.sin((x5 * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x5) => x5 === 0 ? 0 : x5 === 1 ? 1 : x5 < 0.5 ? -(Math.pow(2, 20 * x5 - 10) * Math.sin((20 * x5 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x5 + 10) * Math.sin((20 * x5 - 11.125) * c5) / 2 + 1,
  easeInBounce: (x5) => 1 - bounceOut(1 - x5),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x5) => x5 < 0.5 ? (1 - bounceOut(1 - 2 * x5)) / 2 : (1 + bounceOut(2 * x5 - 1)) / 2,
  steps
};
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer2, event) {
  if (observer2.eventObserved) {
    observer2.eventObserved(event);
  } else {
    observer2(event);
  }
}
function callFluidObservers(target, event) {
  const observers = target[$observers];
  if (observers) {
    observers.forEach((observer2) => {
      callFluidObserver(observer2, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer2) {
  if (target[$get]) {
    let observers = target[$observers];
    if (!observers) {
      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
    }
    if (!observers.has(observer2)) {
      observers.add(observer2);
      if (target.observerAdded) {
        target.observerAdded(observers.size, observer2);
      }
    }
  }
  return observer2;
}
function removeFluidObserver(target, observer2) {
  const observers = target[$observers];
  if (observers && observers.has(observer2)) {
    const count = observers.size - 1;
    if (count) {
      observers.delete(observer2);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer2);
    }
  }
}
var setHidden = (target, key, value2) => Object.defineProperty(target, key, {
  value: value2,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value2) {
    return value2.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const value22 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (value22) {
      return value22;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_2, p1, p22, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p22)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator2 = (config2) => {
  if (!namedColorRegex)
    namedColorRegex = colors ? (
      // match color names, ignore partial matches
      new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
    ) : (
      // never match
      /^\b$/
    );
  const output = config2.output.map((value2) => {
    return getFluidValue(value2).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value2) => value2.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map(
    (_2, i4) => keyframes.map((values) => {
      if (!(i4 in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i4];
    })
  );
  const interpolators = outputRanges.map(
    (output2) => createInterpolator({ ...config2, output: output2 })
  );
  return (input) => {
    var _a;
    const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value2) => unitRegex.test(value2))) == null ? void 0 : _a.replace(numberRegex, ""));
    let i4 = 0;
    return output[0].replace(
      numberRegex,
      () => `${interpolators[i4++](input)}${missingUnit || ""}`
    ).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(
    `${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`
  );
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(
    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
  );
}
function isAnimatedString(value2) {
  return is.str(value2) && (value2[0] == "#" || /\d/.test(value2) || // Do not identify a CSS variable as an AnimatedString if its SSR
  !isSSR() && cssVariableRegex.test(value2) || value2 in (colors || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? import_react4.useEffect : import_react4.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = (0, import_react3.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update3 = (0, import_react2.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update3(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react5.useState)(
    () => ({
      inputs,
      result: getResult()
    })
  );
  const committed = (0, import_react5.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(
      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
    );
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react5.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i4 = 0; i4 < next.length; i4++) {
    if (next[i4] !== prev[i4]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => (0, import_react6.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value2) {
  const prevRef = (0, import_react7.useRef)();
  (0, import_react7.useEffect)(() => {
    prevRef.current = value2;
  });
  return prevRef.current;
}

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
var React = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var $node = Symbol.for("Animated:node");
var isAnimated = (value2) => !!value2 && value2[$node] === value2;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    setAnimated(this, this);
  }
  /** Get every `AnimatedValue` used by this node. */
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class extends Animated {
  constructor(_value) {
    super();
    this._value = _value;
    this.done = true;
    this.durationProgress = 0;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  /** @internal */
  static create(value2) {
    return new AnimatedValue(value2);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value2, step) {
    if (is.num(value2)) {
      this.lastPosition = value2;
      if (step) {
        value2 = Math.round(value2 / step) * step;
        if (this.done) {
          this.lastPosition = value2;
        }
      }
    }
    if (this._value === value2) {
      return false;
    }
    this._value = value2;
    return true;
  }
  reset() {
    const { done } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done)
        this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class extends AnimatedValue {
  constructor(value2) {
    super(0);
    this._string = null;
    this._toString = createInterpolator({
      output: [value2, value2]
    });
  }
  /** @internal */
  static create(value2) {
    return new AnimatedString(value2);
  }
  getValue() {
    const value2 = this._string;
    return value2 == null ? this._string = this._toString(this._value) : value2;
  }
  setValue(value2) {
    if (is.str(value2)) {
      if (value2 == this._string) {
        return false;
      }
      this._string = value2;
      this._value = 1;
    } else if (super.setValue(value2)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = { dependencies: null };
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values[key] = getFluidValue(source);
      } else if (!animated2) {
        values[key] = source;
      }
    });
    return values;
  }
  /** Replace the raw object data */
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  /** Create a payload set. */
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  /** Add to a payload set. */
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  /** @internal */
  static create(source) {
    return new AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i4) => node.setValue(source[i4])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value2) {
  const nodeType = isAnimatedString(value2) ? AnimatedString : AnimatedValue;
  return nodeType.create(value2);
}
function getAnimatedType(value2) {
  const parentNode = getAnimated(value2);
  return parentNode ? parentNode.constructor : is.arr(value2) ? AnimatedArray : isAnimatedString(value2) ? AnimatedString : AnimatedValue;
}
var withAnimated = (Component, host2) => {
  const hasInstance = (
    // Function components must use "forwardRef" to avoid being
    // re-rendered on every animation frame.
    !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
  );
  return (0, import_react9.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react9.useRef)(null);
    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, import_react9.useCallback)(
      (value2) => {
        instanceRef.current = updateRef(givenRef, value2);
      },
      [givenRef]
    );
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react9.useRef)();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(
            observerRef.current.deps,
            (dep) => removeFluidObserver(dep, observerRef.current)
          );
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0, import_react9.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React.createElement(Component, { ...usedProps, ref });
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style)
    props = {
      ...props,
      style: host2.createAnimatedStyle(props.style)
    };
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value2) {
  if (ref) {
    if (is.fun(ref))
      ref(value2);
    else
      ref.current = value2;
  }
  return value2;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: applyAnimatedValues2 = () => false,
  createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: applyAnimatedValues2,
    createAnimatedStyle,
    getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
var React2 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
function callProp(value2, ...args) {
  return is.fun(value2) ? value2(...args) : value2;
}
var matchProp = (value2, key) => value2 === true || !!(key && value2 && (is.fun(value2) ? value2(key) : toArray(value2).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value2) => value2;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value2 = transform(props[key], key);
    if (!is.und(value2)) {
      defaults2[key] = value2;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = [
  "config",
  "onProps",
  "onStart",
  "onChange",
  "onPause",
  "onResume",
  "onRest"
];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  // Transition props
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  // Internal props
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value2, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value2;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to22 = getForwardProps(props);
  if (to22) {
    const out = { to: to22 };
    eachProp(props, (val, key) => key in to22 || (out[key] = val));
    return out;
  }
  return { ...props };
}
function computeGoal(value2) {
  value2 = getFluidValue(value2);
  return is.arr(value2) ? value2.map(computeGoal) : isAnimatedString(value2) ? globals_exports.createStringInterpolator({
    range: [0, 1],
    output: [value2, value2]
  })(1) : value2;
}
function hasProps(props) {
  for (const _2 in props)
    return true;
  return false;
}
function isAsyncTo(to22) {
  return is.fun(to22) || is.arr(to22) && is.obj(to22[0]);
}
function detachRefs(ctrl, ref) {
  var _a;
  (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  var _a;
  if (ref && ctrl.ref !== ref) {
    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: { tension: 170, friction: 26 },
  gentle: { tension: 120, friction: 14 },
  wobbly: { tension: 180, friction: 12 },
  stiff: { tension: 210, friction: 20 },
  slow: { tension: 280, friction: 60 },
  molasses: { tension: 280, friction: 120 }
};
var defaults = {
  ...config.default,
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
};
var AnimationConfig = class {
  constructor() {
    this.velocity = 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = { ...defaultConfig };
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = { ...defaultConfig, ...newConfig };
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let { frequency, damping } = config2;
  const { mass } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01)
      frequency = 0.01;
    if (damping < 0)
      damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, { key, props, defaultProps, state, actions }) {
  return new Promise((resolve, reject) => {
    let delay;
    let timeout;
    let cancel = matchProp(props.cancel ?? (defaultProps == null ? void 0 : defaultProps.cancel), key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps == null ? void 0 : defaultProps.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout);
      timeout.cancel();
      delay = timeout.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals_exports.skipAnimation) {
        state.delayed = true;
        timeout = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start({ ...props, callId, cancel }, resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
  target.get(),
  results.every((result) => result.finished)
);
var getNoopResult = (value2) => ({
  value: value2,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value2, finished, cancelled = false) => ({
  value: value2,
  finished,
  cancelled
});
var getCancelledResult = (value2) => ({
  value: value2,
  cancelled: true,
  finished: false
});
function runAsync(to22, props, state, target) {
  const { callId, parentId, onRest } = props;
  const { asyncTo: prevTo, promise: prevPromise } = state;
  if (!parentId && to22 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to22;
    const defaultProps = getDefaultProps(
      props,
      (value2, key) => (
        // The `onRest` prop is only called when the `runAsync` promise is resolved.
        key === "onRest" ? void 0 : value2
      )
    );
    let preventBail;
    let bail;
    const bailPromise = new Promise(
      (resolve, reject) => (preventBail = resolve, bail = reject)
    );
    const bailIfEnded = (bailSignal) => {
      const bailResult = (
        // The `cancel` prop or `stop` method was used.
        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
        callId !== state.asyncId && getFinishedResult(target, false)
      );
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAnimationSignal();
      return (async () => {
        if (globals_exports.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };
        props2.parentId = callId;
        eachProp(defaultProps, (value2, key) => {
          if (is.und(props2[key])) {
            props2[key] = value2;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals_exports.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to22)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to22);
      } else {
        animating = Promise.resolve(to22(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAnimationSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t5) => t5.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId)
    state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super(
      "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
    );
  }
};
var SkipAnimationSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
  }
};
var isFrameValue = (value2) => value2 instanceof FrameValue;
var nextId = 1;
var FrameValue = class extends FluidValue {
  constructor() {
    super(...arguments);
    this.id = nextId++;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  /** Get the current value */
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  /** Create a spring that maps our value to another value */
  to(...args) {
    return globals_exports.to(this, args);
  }
  /** @deprecated Use the `to` method instead. */
  interpolate(...args) {
    deprecateInterpolate();
    return globals_exports.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1)
      this._attach();
  }
  observerRemoved(count) {
    if (count == 0)
      this._detach();
  }
  /** Called when the first child is added. */
  _attach() {
  }
  /** Called when the last child is removed. */
  _detach() {
  }
  /** Tell our children about our new value */
  _onChange(value2, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value: value2,
      idle
    });
  }
  /** Tell our children about our new priority */
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.animation = new Animation();
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  /** Equals true when not advancing on each frame. */
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  /**
   * When true, this value has been animated at least once.
   */
  get hasAnimated() {
    return hasAnimated(this);
  }
  /**
   * When true, this value has an unfinished animation,
   * which is either active or paused.
   */
  get isAnimating() {
    return isAnimating(this);
  }
  /**
   * When true, all current and future animations are paused.
   */
  get isPaused() {
    return isPaused(this);
  }
  /**
   *
   *
   */
  get isDelayed() {
    return this._state.delayed;
  }
  /** Advance the current animation by a number of milliseconds */
  advance(dt2) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let { toValues } = anim;
    const { config: config2 } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i4) => {
      if (node2.done)
        return;
      const to22 = (
        // Animated strings always go from 0 to 1.
        node2.constructor == AnimatedString ? 1 : payload ? payload[i4].lastPosition : toValues[i4]
      );
      let finished = anim.immediate;
      let position = to22;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt2;
        const from = anim.fromValues[i4];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i4] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to22 ? 5e-3 : Math.min(1, Math.abs(to22 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p3 = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt2;
              }
            }
            p3 = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p3 = p3 > 1 ? 1 : p3 < 0 ? 0 : p3;
            node2.durationProgress = p3;
          }
          position = from + config2.easing(p3) * (to22 - from);
          velocity = (position - node2.lastPosition) / dt2;
          finished = p3 == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e5 = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e5);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e5;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to22 ? node2.v0 > 0 : from < to22;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt2 / step);
          for (let n4 = 0; n4 < numSteps; ++n4) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to22 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to22 || position > to22 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to22;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to22);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i4].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  /** Set the current value, while stopping the current animation */
  set(value2) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value2);
      this._set(value2);
    });
    return this;
  }
  /**
   * Freeze the active animation in time, as well as any updates merged
   * before `resume` is called.
   */
  pause() {
    this._update({ pause: true });
  }
  /** Resume the animation if paused. */
  resume() {
    this._update({ pause: false });
  }
  /** Skip to the end of the current animation. */
  finish() {
    if (isAnimating(this)) {
      const { to: to22, config: config2 } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to22, false);
        }
        this._stop();
      });
    }
    return this;
  }
  /** Push props into the pending queue. */
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to22, arg2) {
    let queue;
    if (!is.und(to22)) {
      queue = [is.obj(to22) ? to22 : { ...arg2, to: to22 }];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(
      queue.map((props) => {
        const up = this._update(props);
        return up;
      })
    ).then((results) => getCombinedResult(this, results));
  }
  /**
   * Stop the current animation, and cancel any delayed updates.
   *
   * Pass `true` to call `onRest` with `cancelled: true`.
   */
  stop(cancel) {
    const { to: to22 } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to22, cancel));
    return this;
  }
  /** Restart the animation. */
  reset() {
    this._update({ reset: true });
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  /**
   * Parse the `to` and `from` range from the given `props` object.
   *
   * This also ensures the initial value is available to animated components
   * during the render phase.
   */
  _prepareNode(props) {
    const key = this.key || "";
    let { to: to22, from } = props;
    to22 = is.obj(to22) ? to22[key] : to22;
    if (to22 == null || isAsyncTo(to22)) {
      to22 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = { to: to22, from };
    if (!hasAnimated(this)) {
      if (props.reverse)
        [to22, from] = [from, to22];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to22);
      }
    }
    return range;
  }
  /** Every update is processed by this method before merging. */
  _update({ ...props }, isLoop) {
    const { key, defaultProps } = this;
    if (props.default)
      Object.assign(
        defaultProps,
        getDefaultProps(
          props,
          (value2, prop) => /^on/.test(prop) ? resolveProp(value2, key) : value2
        )
      );
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error(
        "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
      );
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(
              this,
              "onPause",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(
              this,
              "onResume",
              getFinishedResult(this, checkFinished(this, this.animation.to)),
              this
            );
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  /** Merge props into the current animation */
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const { key, defaultProps, animation: anim } = this;
    const { to: prevTo, from: prevFrom } = anim;
    let { to: to22 = prevTo, from = prevFrom } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to22))) {
      to22 = from;
    }
    if (props.reverse)
      [to22, from] = [from, to22];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to22, prevTo);
    if (hasToChanged) {
      this._focus(to22);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const { config: config2 } = anim;
    const { decay, velocity } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(
        config2,
        callProp(props.config, key),
        // Avoid calling the same "config" prop twice.
        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0
      );
    }
    let node = getAnimated(this);
    if (!node || is.und(to22)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = (
      // When `reset` is undefined, the `from` prop implies `reset: true`,
      // except for declarative updates. When `reset` is defined, there
      // must exist a value to animate from.
      is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key)
    );
    const value2 = reset ? from : this.get();
    const goal = computeGoal(to22);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to22);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else
          throw Error(
            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
          );
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to22);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value2), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to22) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const { onRest } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed)
          raf.batchedUpdates(() => {
            var _a;
            anim.changed = !reset;
            onRest == null ? void 0 : onRest(result, this);
            if (reset) {
              callProp(defaultProps.onRest, result);
            } else {
              (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
            }
          });
      }
    }
    if (reset) {
      this._set(value2);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value2));
    }
  }
  /** Update the `animation.to` value, which might be a `FluidValue` */
  _focus(value2) {
    const anim = this.animation;
    if (value2 !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value2;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      addFluidObserver(to22, this);
      if (isFrameValue(to22)) {
        priority2 = to22.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const { to: to22 } = this.animation;
    if (hasFluidValue(to22)) {
      removeFluidObserver(to22, this);
    }
  }
  /**
   * Update the current value from outside the frameloop,
   * and return the `Animated` node.
   */
  _set(arg, idle = true) {
    const value2 = getFluidValue(arg);
    if (!is.und(value2)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value2, oldNode.getValue())) {
        const nodeType = getAnimatedType(value2);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value2));
        } else {
          oldNode.setValue(value2);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value2, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(
        this,
        "onStart",
        getFinishedResult(this, checkFinished(this, anim.to)),
        this
      );
    }
  }
  _onChange(value2, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value2, this);
    }
    callProp(this.defaultProps.onChange, value2, this);
    super._onChange(value2, idle);
  }
  // This method resets the animation state (even if already animating) to
  // ensure the latest from/to range is used, and it also ensures this spring
  // is added to the frameloop.
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals_exports.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  /**
   * Exit the frameloop and notify `onRest` listeners.
   *
   * Always wrap `_stop` calls with `batchedUpdates`.
   */
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to22) {
  const goal = computeGoal(to22);
  const value2 = computeGoal(target.get());
  return isEqual(value2, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to22 = props.to) {
  const loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate({
      ...props,
      loop: loop2,
      // Avoid updating default props when looping.
      default: false,
      // Never loop the `pause` prop.
      pause: void 0,
      // For the "reverse" prop to loop as expected, the "to" prop
      // must be undefined. The "reverse" prop is ignored when the
      // "to" prop is an array or function.
      to: !reverse || isAsyncTo(to22) ? to22 : void 0,
      // Ignore the "from" prop except on reset.
      from: reset ? props.from : void 0,
      reset,
      // The "loop" prop can return a "useSpring" props object to
      // override any of the original props.
      ...overrides
    });
  }
}
function createUpdate(props) {
  const { to: to22, from } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to22))
    findDefined(to22, keys);
  if (is.obj(from))
    findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update22 = createUpdate(props);
  if (is.und(update22.default)) {
    update22.default = getDefaultProps(update22);
  }
  return update22;
}
function findDefined(values, keys) {
  eachProp(values, (value2, key) => value2 != null && keys.add(key));
}
var ACTIVE_EVENTS = [
  "onStart",
  "onRest",
  "onChange",
  "onPause",
  "onResume"
];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _a, _b, _c, _d;
  (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
  (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId2 = 1;
var Controller = class {
  constructor(props, flush3) {
    this.id = nextId2++;
    this.springs = {};
    this.queue = [];
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush3) {
      this._flush = flush3;
    }
    if (props) {
      this.start({ default: true, ...props });
    }
  }
  /**
   * Equals `true` when no spring values are in the frameloop, and
   * no async animation is currently active.
   */
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  /** Get the current values of our springs */
  get() {
    const values = {};
    this.each((spring, key) => values[key] = spring.get());
    return values;
  }
  /** Set the current values without animating. */
  set(values) {
    for (const key in values) {
      const value2 = values[key];
      if (!is.und(value2)) {
        this.springs[key].set(value2);
      }
    }
  }
  /** Push an update onto the queue of each value. */
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  /**
   * Start the queued animations for every spring, and resolve the returned
   * promise once all queued animations have finished or been cancelled.
   *
   * When you pass a queue (instead of nothing), that queue is used instead of
   * the queued animations added with the `update` method, which are left alone.
   */
  start(props) {
    let { queue } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  /** @internal */
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  /** Freeze the active animation in time */
  pause(keys) {
    if (is.und(keys)) {
      this.start({ pause: true });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  /** Resume the animation if paused. */
  resume(keys) {
    if (is.und(keys)) {
      this.start({ pause: false });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  /** Call a function once per spring value */
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  /** @internal Called at the end of every animation frame */
  _onFrame() {
    const { onStart, onChange, onRest } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values;
        onRest2(result, this, this._item);
      });
    }
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else
      return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
    (results) => getCombinedResult(ctrl, results)
  );
}
async function flushUpdate(ctrl, props, isLoop) {
  const { keys, to: to22, from, loop: loop2, onRest, onResolve } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to22 === false)
    props.to = null;
  if (from === false)
    props.from = null;
  const asyncTo = is.arr(to22) || is.fun(to22) ? to22 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({ finished, cancelled }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished)
              result2.finished = false;
            if (cancelled)
              result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map(
    (key) => ctrl.springs[key].start(props)
  );
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(
      scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(
                runAsync(
                  asyncTo,
                  props2,
                  state,
                  ctrl
                )
              );
            }
          }
        }
      })
    );
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to22);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = { ...ctrl.springs };
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = { ...props2, to: void 0 };
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
var SpringContext = ({
  children,
  ...props
}) => {
  const inherited = (0, import_react11.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
  const { Provider } = ctx;
  return React2.createElement(Provider, { value: props }, children);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, React2.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i4) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = _getProps(props, ctrl, i4);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i4 = current.indexOf(ctrl);
    if (~i4)
      current.splice(i4, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values) {
    each(current, (ctrl, i4) => {
      const update22 = is.fun(values) ? values(i4, ctrl) : values;
      if (update22) {
        ctrl.set(update22);
      }
    });
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i4) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update22 = this._getProps(props, ctrl, i4);
        if (update22) {
          results.push(ctrl.start(update22));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i4) => ctrl.update(this._getProps(props, ctrl, i4)));
    return this;
  };
  const _getProps = function(arg, ctrl, index) {
    return is.fun(arg) ? arg(index, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps)
    deps = [];
  const ref = (0, import_react10.useMemo)(
    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
    []
  );
  const layoutId = (0, import_react10.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react10.useMemo)(
    () => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }),
    []
  );
  const ctrls = (0, import_react10.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react10.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react10.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i4 = startIndex; i4 < endIndex; i4++) {
      const ctrl = ctrls.current[i4] || (ctrls.current[i4] = new Controller(null, state.flush));
      const update22 = propsFn ? propsFn(i4, ctrl) : props[i4];
      if (update22) {
        updates[i4] = declareUpdate(update22);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i4) => getSprings(ctrl, updates[i4]));
  const context = (0, import_react10.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const { queue } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i4) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({ default: context });
      }
      const update22 = updates[i4];
      if (update22) {
        replaceRef(ctrl, update22.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update22);
        } else {
          ctrl.start(update22);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values = springs.map((x5) => ({ ...x5 }));
  return ref ? [values, ref] : values;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values], ref] = useSprings(
    1,
    isFn ? props : [props],
    isFn ? deps || [] : deps
  );
  return isFn || arguments.length == 2 ? [values, ref] : values;
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.source = source;
    this.idle = true;
    this._active = /* @__PURE__ */ new Set();
    this.calc = createInterpolator(...args);
    const value2 = this._get();
    const nodeType = getAnimatedType(value2);
    setAnimated(this, nodeType.create(value2));
  }
  advance(_dt) {
    const value2 = this._get();
    const oldValue = this.get();
    if (!isEqual(value2, oldValue)) {
      getAnimated(this).setValue(value2);
      this._onChange(value2, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals_exports.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  // Observe our sources only when we're observed.
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  // Stop observing our sources once we have no observers.
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  /** @internal */
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce(
        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
        0
      );
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
var to2 = (source, ...args) => new Interpolation(source, args);
globals_exports.assign({
  createStringInterpolator: createStringInterpolator2,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
var import_react_dom = __toESM(require_react_dom(), 1);
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value2) {
  if (value2 == null || typeof value2 === "boolean" || value2 === "")
    return "";
  if (typeof value2 === "number" && value2 !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
    return value2 + "px";
  return ("" + value2).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const {
    className,
    style,
    children,
    scrollTop,
    scrollLeft,
    viewBox,
    ...attributes
  } = props;
  const values = Object.values(attributes);
  const names = Object.keys(attributes).map(
    (name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
      /([A-Z])/g,
      // Attributes are written in dash case
      (n4) => "-" + n4.toLowerCase()
    ))
  );
  if (children !== void 0) {
    instance.textContent = children;
  }
  for (const name in style) {
    if (style.hasOwnProperty(name)) {
      const value2 = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value2);
      } else {
        instance.style[name] = value2;
      }
    }
  }
  names.forEach((name, i4) => {
    instance.setAttribute(name, values[i4]);
  });
  if (className !== void 0) {
    instance.className = className;
  }
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
  if (viewBox !== void 0) {
    instance.setAttribute("viewBox", viewBox);
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value2, unit) => is.num(value2) && value2 !== 0 ? value2 + unit : value2;
var isValueIdentity = (value2, id) => is.arr(value2) ? value2.every((v4) => isValueIdentity(v4, id)) : is.num(value2) ? value2 === id : parseFloat(value2) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor({ x: x5, y: y4, z: z4, ...style }) {
    const inputs = [];
    const transforms = [];
    if (x5 || y4 || z4) {
      inputs.push([x5 || 0, y4 || 0, z4 || 0]);
      transforms.push((xyz) => [
        `translate3d(${xyz.map((v4) => addUnit(v4, "px")).join(",")})`,
        // prettier-ignore
        isValueIdentity(xyz, 0)
      ]);
    }
    eachProp(style, (value2, key) => {
      if (key === "transform") {
        inputs.push([value2 || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value2))
          return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value2));
        transforms.push(
          key === "rotate3d" ? ([x22, y22, z22, deg]) => [
            `rotate3d(${x22},${y22},${z22},${addUnit(deg, unit)})`,
            isValueIdentity(deg, 0)
          ] : (input) => [
            `${key}(${input.map((v4) => addUnit(v4, unit)).join(",")})`,
            isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
          ]
        );
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this.inputs = inputs;
    this.transforms = transforms;
    this._value = null;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity = true;
    each(this.inputs, (input, i4) => {
      const arg1 = getFluidValue(input[0]);
      const [t5, id] = this.transforms[i4](
        is.arr(arg1) ? arg1 : input.map(getFluidValue)
      );
      transform += " " + t5;
      identity = identity && id;
    });
    return identity ? "none" : transform;
  }
  // Start observing our inputs once we have an observer.
  observerAdded(count) {
    if (count == 1)
      each(
        this.inputs,
        (input) => each(
          input,
          (value2) => hasFluidValue(value2) && addFluidObserver(value2, this)
        )
      );
  }
  // Stop observing our inputs once we have no observers.
  observerRemoved(count) {
    if (count == 0)
      each(
        this.inputs,
        (input) => each(
          input,
          (value2) => hasFluidValue(value2) && removeFluidObserver(value2, this)
        )
      );
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
globals_exports.assign({
  batchedUpdates: import_react_dom.unstable_batchedUpdates,
  createStringInterpolator: createStringInterpolator2,
  colors: colors2
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getComponentProps: ({ scrollTop, scrollLeft, ...props }) => props
});
var animated = host.animated;

// node_modules/@nivo/tooltip/dist/nivo-tooltip.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
function v() {
  return v = Object.assign ? Object.assign.bind() : function(t5) {
    for (var i4 = 1; i4 < arguments.length; i4++) {
      var o4 = arguments[i4];
      for (var n4 in o4) Object.prototype.hasOwnProperty.call(o4, n4) && (t5[n4] = o4[n4]);
    }
    return t5;
  }, v.apply(this, arguments);
}
var x = { pointerEvents: "none", position: "absolute", zIndex: 10, top: 0, left: 0 };
var m = function(t5, i4) {
  return "translate(" + t5 + "px, " + i4 + "px)";
};
var b = (0, import_react15.memo)(function(t5) {
  var o4, n4 = t5.position, r4 = t5.anchor, e5 = t5.children, l3 = Et(), u3 = Zr(), p3 = u3.animate, f3 = u3.config, b3 = Gt(), g3 = b3[0], w4 = b3[1], T4 = (0, import_react15.useRef)(false), C4 = void 0, E3 = false, P2 = w4.width > 0 && w4.height > 0, j3 = Math.round(n4[0]), N2 = Math.round(n4[1]);
  P2 && ("top" === r4 ? (j3 -= w4.width / 2, N2 -= w4.height + 14) : "right" === r4 ? (j3 += 14, N2 -= w4.height / 2) : "bottom" === r4 ? (j3 -= w4.width / 2, N2 += 14) : "left" === r4 ? (j3 -= w4.width + 14, N2 -= w4.height / 2) : "center" === r4 && (j3 -= w4.width / 2, N2 -= w4.height / 2), C4 = { transform: m(j3, N2) }, T4.current || (E3 = true), T4.current = [j3, N2]);
  var O3 = useSpring({ to: C4, config: f3, immediate: !p3 || E3 }), V3 = v({}, x, l3.tooltip, { transform: null != (o4 = O3.transform) ? o4 : m(j3, N2) });
  return (0, import_jsx_runtime.jsx)(animated.div, { ref: g3, style: V3, children: e5 });
});
b.displayName = "TooltipWrapper";
var g = (0, import_react15.memo)(function(t5) {
  var i4 = t5.size, o4 = void 0 === i4 ? 12 : i4, n4 = t5.color, r4 = t5.style;
  return (0, import_jsx_runtime.jsx)("span", { style: v({ display: "block", width: o4, height: o4, background: n4 }, void 0 === r4 ? {} : r4) });
});
var w = (0, import_react15.memo)(function(t5) {
  var i4, o4 = t5.id, n4 = t5.value, r4 = t5.format, e5 = t5.enableChip, l3 = void 0 !== e5 && e5, a4 = t5.color, c9 = t5.renderContent, h2 = Et(), d3 = Dt(r4);
  if ("function" == typeof c9) i4 = c9();
  else {
    var f3 = n4;
    void 0 !== d3 && void 0 !== f3 && (f3 = d3(f3)), i4 = (0, import_jsx_runtime.jsxs)("div", { style: h2.tooltip.basic, children: [l3 && (0, import_jsx_runtime.jsx)(g, { color: a4, style: h2.tooltip.chip }), void 0 !== f3 ? (0, import_jsx_runtime.jsxs)("span", { children: [o4, ": ", (0, import_jsx_runtime.jsx)("strong", { children: "" + f3 })] }) : o4] });
  }
  return (0, import_jsx_runtime.jsx)("div", { style: h2.tooltip.container, children: i4 });
});
var T = { width: "100%", borderCollapse: "collapse" };
var C = (0, import_react15.memo)(function(t5) {
  var i4, o4 = t5.title, n4 = t5.rows, r4 = void 0 === n4 ? [] : n4, e5 = t5.renderContent, l3 = Et();
  return r4.length ? (i4 = "function" == typeof e5 ? e5() : (0, import_jsx_runtime.jsxs)("div", { children: [o4 && o4, (0, import_jsx_runtime.jsx)("table", { style: v({}, T, l3.tooltip.table), children: (0, import_jsx_runtime.jsx)("tbody", { children: r4.map(function(t6, i5) {
    return (0, import_jsx_runtime.jsx)("tr", { children: t6.map(function(t7, i6) {
      return (0, import_jsx_runtime.jsx)("td", { style: l3.tooltip.tableCell, children: t7 }, i6);
    }) }, i5);
  }) }) })] }), (0, import_jsx_runtime.jsx)("div", { style: l3.tooltip.container, children: i4 })) : null;
});
C.displayName = "TableTooltip";
var E = (0, import_react15.memo)(function(t5) {
  var i4 = t5.x0, n4 = t5.x1, r4 = t5.y0, e5 = t5.y1, l3 = Et(), d3 = Zr(), u3 = d3.animate, p3 = d3.config, f3 = (0, import_react15.useMemo)(function() {
    return v({}, l3.crosshair.line, { pointerEvents: "none" });
  }, [l3.crosshair.line]), x5 = useSpring({ x1: i4, x2: n4, y1: r4, y2: e5, config: p3, immediate: !u3 });
  return (0, import_jsx_runtime.jsx)(animated.line, v({}, x5, { fill: "none", style: f3 }));
});
E.displayName = "CrosshairLine";
var P = (0, import_react15.memo)(function(t5) {
  var i4, o4, n4 = t5.width, r4 = t5.height, e5 = t5.type, l3 = t5.x, a4 = t5.y;
  return "cross" === e5 ? (i4 = { x0: l3, x1: l3, y0: 0, y1: r4 }, o4 = { x0: 0, x1: n4, y0: a4, y1: a4 }) : "top-left" === e5 ? (i4 = { x0: l3, x1: l3, y0: 0, y1: a4 }, o4 = { x0: 0, x1: l3, y0: a4, y1: a4 }) : "top" === e5 ? i4 = { x0: l3, x1: l3, y0: 0, y1: a4 } : "top-right" === e5 ? (i4 = { x0: l3, x1: l3, y0: 0, y1: a4 }, o4 = { x0: l3, x1: n4, y0: a4, y1: a4 }) : "right" === e5 ? o4 = { x0: l3, x1: n4, y0: a4, y1: a4 } : "bottom-right" === e5 ? (i4 = { x0: l3, x1: l3, y0: a4, y1: r4 }, o4 = { x0: l3, x1: n4, y0: a4, y1: a4 }) : "bottom" === e5 ? i4 = { x0: l3, x1: l3, y0: a4, y1: r4 } : "bottom-left" === e5 ? (i4 = { x0: l3, x1: l3, y0: a4, y1: r4 }, o4 = { x0: 0, x1: l3, y0: a4, y1: a4 }) : "left" === e5 ? o4 = { x0: 0, x1: l3, y0: a4, y1: a4 } : "x" === e5 ? i4 = { x0: l3, x1: l3, y0: 0, y1: r4 } : "y" === e5 && (o4 = { x0: 0, x1: n4, y0: a4, y1: a4 }), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [i4 && (0, import_jsx_runtime.jsx)(E, { x0: i4.x0, x1: i4.x1, y0: i4.y0, y1: i4.y1 }), o4 && (0, import_jsx_runtime.jsx)(E, { x0: o4.x0, x1: o4.x1, y0: o4.y0, y1: o4.y1 })] });
});
P.displayName = "Crosshair";
var j = (0, import_react15.createContext)({ showTooltipAt: function() {
}, showTooltipFromEvent: function() {
}, hideTooltip: function() {
} });
var N = { isVisible: false, position: [null, null], content: null, anchor: null };
var O = (0, import_react15.createContext)(N);
var V = function(t5) {
  var i4 = (0, import_react15.useState)(N), n4 = i4[0], l3 = i4[1], a4 = (0, import_react15.useCallback)(function(t6, i5, o4) {
    var n5 = i5[0], r4 = i5[1];
    void 0 === o4 && (o4 = "top"), l3({ isVisible: true, position: [n5, r4], anchor: o4, content: t6 });
  }, [l3]), c9 = (0, import_react15.useCallback)(function(i5, o4, n5) {
    void 0 === n5 && (n5 = "top");
    var r4 = t5.current.getBoundingClientRect(), e5 = t5.current.offsetWidth, a5 = e5 === r4.width ? 1 : e5 / r4.width, c10 = (o4.clientX - r4.left) * a5, s5 = (o4.clientY - r4.top) * a5;
    "left" !== n5 && "right" !== n5 || (n5 = c10 < r4.width / 2 ? "right" : "left"), l3({ isVisible: true, position: [c10, s5], anchor: n5, content: i5 });
  }, [t5, l3]), s4 = (0, import_react15.useCallback)(function() {
    l3(N);
  }, [l3]);
  return { actions: (0, import_react15.useMemo)(function() {
    return { showTooltipAt: a4, showTooltipFromEvent: c9, hideTooltip: s4 };
  }, [a4, c9, s4]), state: n4 };
};
var k = function() {
  var t5 = (0, import_react15.useContext)(j);
  if (void 0 === t5) throw new Error("useTooltip must be used within a TooltipProvider");
  return t5;
};
var z = function() {
  var t5 = (0, import_react15.useContext)(O);
  if (void 0 === t5) throw new Error("useTooltipState must be used within a TooltipProvider");
  return t5;
};
var A = function(t5) {
  return t5.isVisible;
};
var F = function() {
  var t5 = z();
  return A(t5) ? (0, import_jsx_runtime.jsx)(b, { position: t5.position, anchor: t5.anchor, children: t5.content }) : null;
};
var M = function(t5) {
  var i4 = t5.container, o4 = t5.children, n4 = V(i4), r4 = n4.actions, e5 = n4.state;
  return (0, import_jsx_runtime.jsx)(j.Provider, { value: r4, children: (0, import_jsx_runtime.jsx)(O.Provider, { value: e5, children: o4 }) });
};

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_merge = __toESM(require_merge());
var import_get = __toESM(require_get());
var import_set = __toESM(require_set());
var import_isString = __toESM(require_isString());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_last = __toESM(require_last());
var import_isArray = __toESM(require_isArray());

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n4 = specifier.length / 6 | 0, colors3 = new Array(n4), i4 = 0;
  while (i4 < n4) colors3[i4] = "#" + specifier.slice(i4 * 6, ++i4 * 6);
  return colors3;
}

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default2 = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default2 = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default2 = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default2 = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default2 = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default2 = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default2 = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default2 = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default2 = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme55) => rgbBasis(scheme55[scheme55.length - 1]);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme28 = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default2 = ramp_default(scheme28);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme29 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default2 = ramp_default(scheme29);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme30 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default2 = ramp_default(scheme30);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme31 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default2 = ramp_default(scheme31);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme32 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default2 = ramp_default(scheme32);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme33 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default2 = ramp_default(scheme33);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme34 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default2 = ramp_default(scheme34);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme35 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default2 = ramp_default(scheme35);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme36 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default2 = ramp_default(scheme36);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme37 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default2 = ramp_default(scheme37);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme38 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default2 = ramp_default(scheme38);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme39 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default2 = ramp_default(scheme39);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme40 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default2 = ramp_default(scheme40);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme41 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default2 = ramp_default(scheme41);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme42 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default2 = ramp_default(scheme42);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme43 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default2 = ramp_default(scheme43);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme44 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default2 = ramp_default(scheme44);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme45 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default2 = ramp_default(scheme45);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme46 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default2 = ramp_default(scheme46);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme47 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default2 = ramp_default(scheme47);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme48 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default2 = ramp_default(scheme48);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme49 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default2 = ramp_default(scheme49);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme50 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default2 = ramp_default(scheme50);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme51 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default2 = ramp_default(scheme51);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme52 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default2 = ramp_default(scheme52);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme53 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default2 = ramp_default(scheme53);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme54 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default2 = ramp_default(scheme54);

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm2 = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool2 = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c6 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

// node_modules/@nivo/core/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range) {
  var n4 = range.length;
  return function(t5) {
    return range[Math.max(0, Math.min(n4 - 1, Math.floor(t5 * n4)))];
  };
}
var viridis_default2 = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma2 = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno2 = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma2 = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_isFunction = __toESM(require_isFunction());
var import_without = __toESM(require_without());

// node_modules/d3-path/src/path.js
var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x5, y4) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y4);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x5, y4) {
    this._ += "L" + (this._x1 = +x5) + "," + (this._y1 = +y4);
  },
  quadraticCurveTo: function(x1, y1, x5, y4) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x5) + "," + (this._y1 = +y4);
  },
  bezierCurveTo: function(x1, y1, x22, y22, x5, y4) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x22 + "," + +y22 + "," + (this._x1 = +x5) + "," + (this._y1 = +y4);
  },
  arcTo: function(x1, y1, x22, y22, r4) {
    x1 = +x1, y1 = +y1, x22 = +x22, y22 = +y22, r4 = +r4;
    var x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y22 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r4 < 0) throw new Error("negative radius: " + r4);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r4) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x22 - x0, y20 = y22 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l3 = r4 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l3 / l01, t21 = l3 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r4 + "," + r4 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x5, y4, r4, a0, a1, ccw) {
    x5 = +x5, y4 = +y4, r4 = +r4, ccw = !!ccw;
    var dx = r4 * Math.cos(a0), dy = r4 * Math.sin(a0), x0 = x5 + dx, y0 = y4 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r4 < 0) throw new Error("negative radius: " + r4);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r4) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r4 + "," + r4 + ",0,1," + cw + "," + (x5 - dx) + "," + (y4 - dy) + "A" + r4 + "," + r4 + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r4 + "," + r4 + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x5 + r4 * Math.cos(a1)) + "," + (this._y1 = y4 + r4 * Math.sin(a1));
    }
  },
  rect: function(x5, y4, w4, h2) {
    this._ += "M" + (this._x0 = this._x1 = +x5) + "," + (this._y0 = this._y1 = +y4) + "h" + +w4 + "v" + +h2 + "h" + -w4 + "Z";
  },
  toString: function() {
    return this._;
  }
};
var path_default = path;

// node_modules/d3-shape/src/constant.js
function constant_default(x5) {
  return function constant2() {
    return x5;
  };
}

// node_modules/d3-shape/src/math.js
var epsilon2 = 1e-12;
var pi2 = Math.PI;
var halfPi = pi2 / 2;
var tau2 = 2 * pi2;

// node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x5, y4);
        break;
    }
  }
};
function linear_default(context) {
  return new Linear(context);
}

// node_modules/d3-shape/src/point.js
function x2(p3) {
  return p3[0];
}
function y2(p3) {
  return p3[1];
}

// node_modules/d3-shape/src/line.js
function line_default() {
  var x5 = x2, y4 = y2, defined = constant_default(true), context = null, curve = linear_default, output = null;
  function line(data) {
    var i4, n4 = data.length, d3, defined0 = false, buffer;
    if (context == null) output = curve(buffer = path_default());
    for (i4 = 0; i4 <= n4; ++i4) {
      if (!(i4 < n4 && defined(d3 = data[i4], i4, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x5(d3, i4, data), +y4(d3, i4, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line.x = function(_2) {
    return arguments.length ? (x5 = typeof _2 === "function" ? _2 : constant_default(+_2), line) : x5;
  };
  line.y = function(_2) {
    return arguments.length ? (y4 = typeof _2 === "function" ? _2 : constant_default(+_2), line) : y4;
  };
  line.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant_default(!!_2), line) : defined;
  };
  line.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line) : context;
  };
  return line;
}

// node_modules/d3-shape/src/curve/radial.js
var curveRadialLinear = curveRadial(linear_default);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a4, r4) {
    this._curve.point(r4 * Math.sin(a4), r4 * -Math.cos(a4));
  }
};
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}

// node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;

// node_modules/d3-shape/src/symbol/diamond.js
var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

// node_modules/d3-shape/src/symbol/star.js
var kr = Math.sin(pi2 / 10) / Math.sin(7 * pi2 / 10);
var kx = Math.sin(tau2 / 10) * kr;
var ky = -Math.cos(tau2 / 10) * kr;

// node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = Math.sqrt(3);

// node_modules/d3-shape/src/symbol/wye.js
var s = Math.sqrt(3) / 2;
var k2 = 1 / Math.sqrt(12);
var a = (k2 / 2 + 1) * 3;

// node_modules/d3-shape/src/noop.js
function noop_default() {
}

// node_modules/d3-shape/src/curve/basis.js
function point(that, x5, y4) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x5) / 6,
    (that._y0 + 4 * that._y1 + y4) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basis_default(context) {
  return new Basis(context);
}

// node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x5, this._y2 = y4;
        break;
      case 1:
        this._point = 2;
        this._x3 = x5, this._y3 = y4;
        break;
      case 2:
        this._point = 3;
        this._x4 = x5, this._y4 = y4;
        this._context.moveTo((this._x0 + 4 * this._x1 + x5) / 6, (this._y0 + 4 * this._y1 + y4) / 6);
        break;
      default:
        point(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisClosed_default(context) {
  return new BasisClosed(context);
}

// node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x5) / 6, y0 = (this._y0 + 4 * this._y1 + y4) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y4;
  }
};
function basisOpen_default(context) {
  return new BasisOpen(context);
}

// node_modules/d3-shape/src/curve/bundle.js
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x5 = this._x, y4 = this._y, j3 = x5.length - 1;
    if (j3 > 0) {
      var x0 = x5[0], y0 = y4[0], dx = x5[j3] - x0, dy = y4[j3] - y0, i4 = -1, t5;
      while (++i4 <= j3) {
        t5 = i4 / j3;
        this._basis.point(
          this._beta * x5[i4] + (1 - this._beta) * (x0 + t5 * dx),
          this._beta * y4[i4] + (1 - this._beta) * (y0 + t5 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x5, y4) {
    this._x.push(+x5);
    this._y.push(+y4);
  }
};
var bundle_default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle.beta = function(beta2) {
    return custom(+beta2);
  };
  return bundle;
}(0.85);

// node_modules/d3-shape/src/curve/cardinal.js
function point2(that, x5, y4) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x5),
    that._y2 + that._k * (that._y1 - y4),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point2(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
        this._x1 = x5, this._y1 = y4;
        break;
      case 2:
        this._point = 3;
      default:
        point2(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinal_default = function custom2(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom2(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalClosed.js
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y4;
        break;
      default:
        point2(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalClosed_default = function custom3(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom3(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/cardinalOpen.js
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point2(this, x5, y4);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var cardinalOpen_default = function custom4(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal.tension = function(tension2) {
    return custom4(+tension2);
  };
  return cardinal;
}(0);

// node_modules/d3-shape/src/curve/catmullRom.js
function point3(that, x5, y4) {
  var x1 = that._x1, y1 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon2) {
    var a4 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n4 = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a4 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n4;
    y1 = (y1 * a4 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n4;
  }
  if (that._l23_a > epsilon2) {
    var b3 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m4 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b3 + that._x1 * that._l23_2a - x5 * that._l12_2a) / m4;
    y22 = (y22 * b3 + that._y1 * that._l23_2a - y4 * that._l12_2a) / m4;
  }
  that._context.bezierCurveTo(x1, y1, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point3(this, x5, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRom_default = function custom5(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom5(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomClosed.js
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x5, this._y3 = y4;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x5, this._y4 = y4);
        break;
      case 2:
        this._point = 3;
        this._x5 = x5, this._y5 = y4;
        break;
      default:
        point3(this, x5, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomClosed_default = function custom6(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom6(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/catmullRomOpen.js
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    if (this._point) {
      var x23 = this._x2 - x5, y23 = this._y2 - y4;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point3(this, x5, y4);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x5;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y4;
  }
};
var catmullRomOpen_default = function custom7(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom.alpha = function(alpha2) {
    return custom7(+alpha2);
  };
  return catmullRom;
}(0.5);

// node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop_default,
  areaEnd: noop_default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    if (this._point) this._context.lineTo(x5, y4);
    else this._point = 1, this._context.moveTo(x5, y4);
  }
};
function linearClosed_default(context) {
  return new LinearClosed(context);
}

// node_modules/d3-shape/src/curve/monotone.js
function sign(x5) {
  return x5 < 0 ? -1 : 1;
}
function slope3(that, x22, y22) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p3 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p3)) || 0;
}
function slope2(that, t5) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t5) / 2 : t5;
}
function point4(that, t0, t1) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point4(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    var t1 = NaN;
    x5 = +x5, y4 = +y4;
    if (x5 === this._x1 && y4 === this._y1) return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point4(this, slope2(this, t1 = slope3(this, x5, y4)), t1);
        break;
      default:
        point4(this, this._t0, t1 = slope3(this, x5, y4));
        break;
    }
    this._x0 = this._x1, this._x1 = x5;
    this._y0 = this._y1, this._y1 = y4;
    this._t0 = t1;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x5, y4) {
  MonotoneX.prototype.point.call(this, y4, x5);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x5, y4) {
    this._context.moveTo(y4, x5);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x5, y4) {
    this._context.lineTo(y4, x5);
  },
  bezierCurveTo: function(x1, y1, x22, y22, x5, y4) {
    this._context.bezierCurveTo(y1, x1, y22, x22, y4, x5);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}

// node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x5 = this._x, y4 = this._y, n4 = x5.length;
    if (n4) {
      this._line ? this._context.lineTo(x5[0], y4[0]) : this._context.moveTo(x5[0], y4[0]);
      if (n4 === 2) {
        this._context.lineTo(x5[1], y4[1]);
      } else {
        var px = controlPoints(x5), py = controlPoints(y4);
        for (var i0 = 0, i1 = 1; i1 < n4; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x5[i1], y4[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n4 === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x5, y4) {
    this._x.push(+x5);
    this._y.push(+y4);
  }
};
function controlPoints(x5) {
  var i4, n4 = x5.length - 1, m4, a4 = new Array(n4), b3 = new Array(n4), r4 = new Array(n4);
  a4[0] = 0, b3[0] = 2, r4[0] = x5[0] + 2 * x5[1];
  for (i4 = 1; i4 < n4 - 1; ++i4) a4[i4] = 1, b3[i4] = 4, r4[i4] = 4 * x5[i4] + 2 * x5[i4 + 1];
  a4[n4 - 1] = 2, b3[n4 - 1] = 7, r4[n4 - 1] = 8 * x5[n4 - 1] + x5[n4];
  for (i4 = 1; i4 < n4; ++i4) m4 = a4[i4] / b3[i4 - 1], b3[i4] -= m4, r4[i4] -= m4 * r4[i4 - 1];
  a4[n4 - 1] = r4[n4 - 1] / b3[n4 - 1];
  for (i4 = n4 - 2; i4 >= 0; --i4) a4[i4] = (r4[i4] - a4[i4 + 1]) / b3[i4];
  b3[n4 - 1] = (x5[n4] + a4[n4 - 1]) / 2;
  for (i4 = 0; i4 < n4 - 1; ++i4) b3[i4] = 2 * x5[i4 + 1] - a4[i4 + 1];
  return [a4, b3];
}
function natural_default(context) {
  return new Natural(context);
}

// node_modules/d3-shape/src/curve/step.js
function Step(context, t5) {
  this._context = context;
  this._t = t5;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x5, y4) {
    x5 = +x5, y4 = +y4;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x5, y4) : this._context.moveTo(x5, y4);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y4);
          this._context.lineTo(x5, y4);
        } else {
          var x1 = this._x * (1 - this._t) + x5 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y4);
        }
        break;
      }
    }
    this._x = x5, this._y = y4;
  }
};
function step_default(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}

// node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
  if (!((n4 = series.length) > 1)) return;
  for (var i4 = 1, j3, s0, s1 = series[order[0]], n4, m4 = s1.length; i4 < n4; ++i4) {
    s0 = s1, s1 = series[order[i4]];
    for (j3 = 0; j3 < m4; ++j3) {
      s1[j3][1] += s1[j3][0] = isNaN(s0[j3][1]) ? s0[j3][0] : s0[j3][1];
    }
  }
}

// node_modules/d3-shape/src/order/none.js
function none_default2(series) {
  var n4 = series.length, o4 = new Array(n4);
  while (--n4 >= 0) o4[n4] = n4;
  return o4;
}

// node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
  if (!((n4 = series.length) > 0)) return;
  for (var i4, n4, j3 = 0, m4 = series[0].length, y4; j3 < m4; ++j3) {
    for (y4 = i4 = 0; i4 < n4; ++i4) y4 += series[i4][j3][1] || 0;
    if (y4) for (i4 = 0; i4 < n4; ++i4) series[i4][j3][1] /= y4;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/diverging.js
function diverging_default(series, order) {
  if (!((n4 = series.length) > 0)) return;
  for (var i4, j3 = 0, d3, dy, yp, yn, n4, m4 = series[order[0]].length; j3 < m4; ++j3) {
    for (yp = yn = 0, i4 = 0; i4 < n4; ++i4) {
      if ((dy = (d3 = series[order[i4]][j3])[1] - d3[0]) > 0) {
        d3[0] = yp, d3[1] = yp += dy;
      } else if (dy < 0) {
        d3[1] = yn, d3[0] = yn += dy;
      } else {
        d3[0] = 0, d3[1] = dy;
      }
    }
  }
}

// node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
  if (!((n4 = series.length) > 0)) return;
  for (var j3 = 0, s0 = series[order[0]], n4, m4 = s0.length; j3 < m4; ++j3) {
    for (var i4 = 0, y4 = 0; i4 < n4; ++i4) y4 += series[i4][j3][1] || 0;
    s0[j3][1] += s0[j3][0] = -y4 / 2;
  }
  none_default(series, order);
}

// node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
  if (!((n4 = series.length) > 0) || !((m4 = (s0 = series[order[0]]).length) > 0)) return;
  for (var y4 = 0, j3 = 1, s0, m4, n4; j3 < m4; ++j3) {
    for (var i4 = 0, s1 = 0, s22 = 0; i4 < n4; ++i4) {
      var si = series[order[i4]], sij0 = si[j3][1] || 0, sij1 = si[j3 - 1][1] || 0, s32 = (sij0 - sij1) / 2;
      for (var k4 = 0; k4 < i4; ++k4) {
        var sk = series[order[k4]], skj0 = sk[j3][1] || 0, skj1 = sk[j3 - 1][1] || 0;
        s32 += skj0 - skj1;
      }
      s1 += sij0, s22 += s32 * sij0;
    }
    s0[j3 - 1][1] += s0[j3 - 1][0] = y4;
    if (s1) y4 -= s22 / s1;
  }
  s0[j3 - 1][1] += s0[j3 - 1][0] = y4;
  none_default(series, order);
}

// node_modules/d3-shape/src/order/appearance.js
function appearance_default(series) {
  var peaks = series.map(peak);
  return none_default2(series).sort(function(a4, b3) {
    return peaks[a4] - peaks[b3];
  });
}
function peak(series) {
  var i4 = -1, j3 = 0, n4 = series.length, vi2, vj = -Infinity;
  while (++i4 < n4) if ((vi2 = +series[i4][1]) > vj) vj = vi2, j3 = i4;
  return j3;
}

// node_modules/d3-shape/src/order/ascending.js
function ascending_default(series) {
  var sums = series.map(sum2);
  return none_default2(series).sort(function(a4, b3) {
    return sums[a4] - sums[b3];
  });
}
function sum2(series) {
  var s4 = 0, i4 = -1, n4 = series.length, v4;
  while (++i4 < n4) if (v4 = +series[i4][1]) s4 += v4;
  return s4;
}

// node_modules/d3-shape/src/order/descending.js
function descending_default2(series) {
  return ascending_default(series).reverse();
}

// node_modules/d3-shape/src/order/insideOut.js
function insideOut_default(series) {
  var n4 = series.length, i4, j3, sums = series.map(sum2), order = appearance_default(series), top = 0, bottom = 0, tops = [], bottoms = [];
  for (i4 = 0; i4 < n4; ++i4) {
    j3 = order[i4];
    if (top < bottom) {
      top += sums[j3];
      tops.push(j3);
    } else {
      bottom += sums[j3];
      bottoms.push(j3);
    }
  }
  return bottoms.reverse().concat(tops);
}

// node_modules/d3-shape/src/order/reverse.js
function reverse_default(series) {
  return none_default2(series).reverse();
}

// node_modules/@nivo/core/dist/nivo-core.es.js
var import_isPlainObject = __toESM(require_isPlainObject());
var import_pick = __toESM(require_pick());
var import_isEqual = __toESM(require_isEqual());
function Sr() {
  return Sr = Object.assign ? Object.assign.bind() : function(e5) {
    for (var r4 = 1; r4 < arguments.length; r4++) {
      var t5 = arguments[r4];
      for (var i4 in t5) Object.prototype.hasOwnProperty.call(t5, i4) && (e5[i4] = t5[i4]);
    }
    return e5;
  }, Sr.apply(this, arguments);
}
function jr(e5, r4) {
  if (null == e5) return {};
  var t5, i4, n4 = {}, o4 = Object.keys(e5);
  for (i4 = 0; i4 < o4.length; i4++) t5 = o4[i4], r4.indexOf(t5) >= 0 || (n4[t5] = e5[t5]);
  return n4;
}
var Br = { fill: import_prop_types.default.string, fontSize: import_prop_types.default.number, fontFamily: import_prop_types.default.string };
var Gr = import_prop_types.default.shape({ domain: import_prop_types.default.shape({ line: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, strokeDasharray: import_prop_types.default.string }).isRequired }).isRequired, ticks: import_prop_types.default.shape({ line: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, strokeDasharray: import_prop_types.default.string }).isRequired, text: import_prop_types.default.shape(Sr({}, Br)).isRequired }).isRequired, legend: import_prop_types.default.shape({ text: import_prop_types.default.shape(Sr({}, Br)).isRequired }).isRequired });
var Lr = import_prop_types.default.shape({ line: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, strokeDasharray: import_prop_types.default.string }).isRequired });
var Ir = import_prop_types.default.shape({ hidden: import_prop_types.default.shape({ symbol: import_prop_types.default.shape({ fill: import_prop_types.default.string.isRequired, opacity: import_prop_types.default.number }).isRequired, text: import_prop_types.default.shape(Sr({}, Br, { opacity: import_prop_types.default.number })).isRequired }).isRequired, text: import_prop_types.default.shape(Sr({}, Br)).isRequired });
var Dr = import_prop_types.default.shape({ text: import_prop_types.default.shape(Sr({}, Br)).isRequired });
var Yr = import_prop_types.default.shape({ text: import_prop_types.default.shape(Sr({}, Br)).isRequired });
var Ar = import_prop_types.default.shape({ text: import_prop_types.default.shape(Sr({}, Br)).isRequired });
var Fr = import_prop_types.default.shape({ line: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, strokeDasharray: import_prop_types.default.string }).isRequired });
var Er = import_prop_types.default.shape({ text: import_prop_types.default.shape(Sr({}, Br, { outlineWidth: import_prop_types.default.number.isRequired, outlineColor: import_prop_types.default.string.isRequired })).isRequired, link: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, outlineWidth: import_prop_types.default.number.isRequired, outlineColor: import_prop_types.default.string.isRequired }).isRequired, outline: import_prop_types.default.shape({ stroke: import_prop_types.default.string.isRequired, strokeWidth: import_prop_types.default.number.isRequired, outlineWidth: import_prop_types.default.number.isRequired, outlineColor: import_prop_types.default.string.isRequired }).isRequired, symbol: import_prop_types.default.shape({ fill: import_prop_types.default.string.isRequired, outlineWidth: import_prop_types.default.number.isRequired, outlineColor: import_prop_types.default.string.isRequired }).isRequired });
var Ur = import_prop_types.default.shape({ background: import_prop_types.default.string.isRequired, fontFamily: import_prop_types.default.string.isRequired, fontSize: import_prop_types.default.number.isRequired, textColor: import_prop_types.default.string.isRequired, axis: Gr.isRequired, grid: Lr.isRequired, legends: Ir.isRequired, labels: Dr.isRequired, dots: Yr.isRequired, markers: Ar, crosshair: Fr.isRequired, annotations: Er.isRequired });
var Xr = { background: "transparent", text: { fontFamily: "sans-serif", fontSize: 11, fill: "#333333", outlineWidth: 0, outlineColor: "transparent" }, axis: { domain: { line: { stroke: "transparent", strokeWidth: 1 } }, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: {} }, legend: { text: { fontSize: 12 } } }, grid: { line: { stroke: "#dddddd", strokeWidth: 1 } }, legends: { hidden: { symbol: { fill: "#333333", opacity: 0.6 }, text: { fill: "#333333", opacity: 0.6 } }, text: {}, ticks: { line: { stroke: "#777777", strokeWidth: 1 }, text: { fontSize: 10 } }, title: { text: {} } }, labels: { text: {} }, markers: { lineColor: "#000000", lineStrokeWidth: 1, text: {} }, dots: { text: {} }, tooltip: { container: { background: "white", color: "inherit", fontSize: "inherit", borderRadius: "2px", boxShadow: "0 1px 2px rgba(0, 0, 0, 0.25)", padding: "5px 9px" }, basic: { whiteSpace: "pre", display: "flex", alignItems: "center" }, chip: { marginRight: 7 }, table: {}, tableCell: { padding: "3px 5px" }, tableCellValue: { fontWeight: "bold" } }, crosshair: { line: { stroke: "#000000", strokeWidth: 1, strokeOpacity: 0.75, strokeDasharray: "6 6" } }, annotations: { text: { fontSize: 13, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, link: { stroke: "#000000", strokeWidth: 1, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, outline: { fill: "none", stroke: "#000000", strokeWidth: 2, outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 }, symbol: { fill: "#000000", outlineWidth: 2, outlineColor: "#ffffff", outlineOpacity: 1 } } };
var Hr = ["axis.ticks.text", "axis.legend.text", "legends.title.text", "legends.text", "legends.ticks.text", "legends.title.text", "labels.text", "dots.text", "markers.text", "annotations.text"];
var Kr = function(e5, r4) {
  var t5 = (0, import_merge.default)({}, e5, r4);
  return Hr.forEach(function(e6) {
    void 0 === (0, import_get.default)(t5, e6 + ".fontFamily") && (0, import_set.default)(t5, e6 + ".fontFamily", t5.text.fontFamily), void 0 === (0, import_get.default)(t5, e6 + ".fontSize") && (0, import_set.default)(t5, e6 + ".fontSize", t5.text.fontSize), void 0 === (0, import_get.default)(t5, e6 + ".fill") && (0, import_set.default)(t5, e6 + ".fill", t5.text.fill), void 0 === (0, import_get.default)(t5, e6 + ".outlineWidth") && (0, import_set.default)(t5, e6 + ".outlineWidth", t5.text.outlineWidth), void 0 === (0, import_get.default)(t5, e6 + ".outlineColor") && (0, import_set.default)(t5, e6 + ".outlineColor", t5.text.outlineColor);
  }), t5;
};
var Nr = (0, import_react16.createContext)();
var Vr = function(e5) {
  var t5 = e5.children, i4 = e5.animate, n4 = e5.config, o4 = (0, import_react16.useMemo)(function() {
    var e6 = (0, import_isString.default)(n4) ? config[n4] : n4;
    return { animate: i4, config: e6 };
  }, [i4, n4]);
  return (0, import_jsx_runtime2.jsx)(Nr.Provider, { value: o4, children: t5 });
};
var Jr = { animate: import_prop_types.default.bool, motionConfig: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(Object.keys(config)), import_prop_types.default.shape({ mass: import_prop_types.default.number, tension: import_prop_types.default.number, friction: import_prop_types.default.number, clamp: import_prop_types.default.bool, precision: import_prop_types.default.number, velocity: import_prop_types.default.number, duration: import_prop_types.default.number, easing: import_prop_types.default.func })]) };
Vr.propTypes = { children: import_prop_types.default.node.isRequired, animate: Jr.animate, config: Jr.motionConfig };
var Qr = { animate: true, config: "default" };
Vr.defaultProps = Qr;
var Zr = function() {
  return (0, import_react16.useContext)(Nr);
};
var $r = function(e5) {
  var t5 = Zr(), o4 = t5.animate, a4 = t5.config, l3 = function(e6) {
    var r4 = (0, import_react16.useRef)();
    return (0, import_react16.useEffect)(function() {
      r4.current = e6;
    }, [e6]), r4.current;
  }(e5), s4 = (0, import_react16.useMemo)(function() {
    return string_default(l3, e5);
  }, [l3, e5]), d3 = useSpring({ from: { value: 0 }, to: { value: 1 }, reset: true, config: a4, immediate: !o4 }).value;
  return to2(d3, s4);
};
var et = { nivo: ["#d76445", "#f47560", "#e8c1a0", "#97e3d5", "#61cdbb", "#00b0a7"], BrBG: (0, import_last.default)(scheme28), PRGn: (0, import_last.default)(scheme29), PiYG: (0, import_last.default)(scheme30), PuOr: (0, import_last.default)(scheme31), RdBu: (0, import_last.default)(scheme32), RdGy: (0, import_last.default)(scheme33), RdYlBu: (0, import_last.default)(scheme34), RdYlGn: (0, import_last.default)(scheme35), spectral: (0, import_last.default)(scheme36), blues: (0, import_last.default)(scheme49), greens: (0, import_last.default)(scheme50), greys: (0, import_last.default)(scheme51), oranges: (0, import_last.default)(scheme54), purples: (0, import_last.default)(scheme52), reds: (0, import_last.default)(scheme53), BuGn: (0, import_last.default)(scheme37), BuPu: (0, import_last.default)(scheme38), GnBu: (0, import_last.default)(scheme39), OrRd: (0, import_last.default)(scheme40), PuBuGn: (0, import_last.default)(scheme41), PuBu: (0, import_last.default)(scheme42), PuRd: (0, import_last.default)(scheme43), RdPu: (0, import_last.default)(scheme44), YlGnBu: (0, import_last.default)(scheme45), YlGn: (0, import_last.default)(scheme46), YlOrBr: (0, import_last.default)(scheme47), YlOrRd: (0, import_last.default)(scheme48) };
var rt = Object.keys(et);
var it = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default2, accent: Accent_default2, dark2: Dark2_default2, paired: Paired_default2, pastel1: Pastel1_default2, pastel2: Pastel2_default2, set1: Set1_default2, set2: Set2_default2, set3: Set3_default2, brown_blueGreen: (0, import_last.default)(scheme28), purpleRed_green: (0, import_last.default)(scheme29), pink_yellowGreen: (0, import_last.default)(scheme30), purple_orange: (0, import_last.default)(scheme31), red_blue: (0, import_last.default)(scheme32), red_grey: (0, import_last.default)(scheme33), red_yellow_blue: (0, import_last.default)(scheme34), red_yellow_green: (0, import_last.default)(scheme35), spectral: (0, import_last.default)(scheme36), blues: (0, import_last.default)(scheme49), greens: (0, import_last.default)(scheme50), greys: (0, import_last.default)(scheme51), oranges: (0, import_last.default)(scheme54), purples: (0, import_last.default)(scheme52), reds: (0, import_last.default)(scheme53), blue_green: (0, import_last.default)(scheme37), blue_purple: (0, import_last.default)(scheme38), green_blue: (0, import_last.default)(scheme39), orange_red: (0, import_last.default)(scheme40), purple_blue_green: (0, import_last.default)(scheme41), purple_blue: (0, import_last.default)(scheme42), purple_red: (0, import_last.default)(scheme43), red_purple: (0, import_last.default)(scheme44), yellow_green_blue: (0, import_last.default)(scheme45), yellow_green: (0, import_last.default)(scheme46), yellow_orange_brown: (0, import_last.default)(scheme47), yellow_orange_red: (0, import_last.default)(scheme48) };
var dt = import_prop_types.default.oneOfType([import_prop_types.default.oneOf(rt), import_prop_types.default.func, import_prop_types.default.arrayOf(import_prop_types.default.string)]);
var ut = { basis: basis_default, basisClosed: basisClosed_default, basisOpen: basisOpen_default, bundle: bundle_default, cardinal: cardinal_default, cardinalClosed: cardinalClosed_default, cardinalOpen: cardinalOpen_default, catmullRom: catmullRom_default, catmullRomClosed: catmullRomClosed_default, catmullRomOpen: catmullRomOpen_default, linear: linear_default, linearClosed: linearClosed_default, monotoneX, monotoneY, natural: natural_default, step: step_default, stepAfter, stepBefore };
var ct = Object.keys(ut);
var ft = import_prop_types.default.oneOf(ct);
var pt = ct.filter(function(e5) {
  return e5.endsWith("Closed");
});
var ht = (0, import_without.default)(ct, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var gt = (0, import_without.default)(ct, "bundle", "basisClosed", "basisOpen", "cardinalClosed", "cardinalOpen", "catmullRomClosed", "catmullRomOpen", "linearClosed");
var bt = import_prop_types.default.oneOf(gt);
var yt = { defs: import_prop_types.default.arrayOf(import_prop_types.default.shape({ id: import_prop_types.default.string.isRequired })).isRequired, fill: import_prop_types.default.arrayOf(import_prop_types.default.shape({ id: import_prop_types.default.string.isRequired, match: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["*"]), import_prop_types.default.object, import_prop_types.default.func]).isRequired })).isRequired };
var vt = { ascending: ascending_default, descending: descending_default2, insideOut: insideOut_default, none: none_default2, reverse: reverse_default };
var Rt = Object.keys(vt);
var qt = import_prop_types.default.oneOf(Rt);
var _t = { expand: expand_default, diverging: diverging_default, none: none_default, silhouette: silhouette_default, wiggle: wiggle_default };
var wt = Object.keys(_t);
var xt = import_prop_types.default.oneOf(wt);
var Wt = import_prop_types.default.shape({ top: import_prop_types.default.number, right: import_prop_types.default.number, bottom: import_prop_types.default.number, left: import_prop_types.default.number }).isRequired;
var Ct = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
var zt = import_prop_types.default.oneOf(Ct);
var Mt = ordinal(Set3_default2);
var jt = { top: 0, right: 0, bottom: 0, left: 0 };
var Bt = function(e5, t5, i4) {
  return void 0 === i4 && (i4 = {}), (0, import_react16.useMemo)(function() {
    var r4 = Sr({}, jt, i4);
    return { margin: r4, innerWidth: e5 - r4.left - r4.right, innerHeight: t5 - r4.top - r4.bottom, outerWidth: e5, outerHeight: t5 };
  }, [e5, t5, i4.top, i4.right, i4.bottom, i4.left]);
};
var Gt = function() {
  var e5 = (0, import_react16.useRef)(null), r4 = (0, import_react16.useState)({ left: 0, top: 0, width: 0, height: 0 }), t5 = r4[0], a4 = r4[1], l3 = (0, import_react16.useState)(function() {
    return "undefined" == typeof ResizeObserver ? null : new ResizeObserver(function(e6) {
      var r5 = e6[0];
      return a4(r5.contentRect);
    });
  })[0];
  return (0, import_react16.useEffect)(function() {
    return e5.current && null !== l3 && l3.observe(e5.current), function() {
      null !== l3 && l3.disconnect();
    };
  }, []), [e5, t5];
};
var Lt = function(e5) {
  return (0, import_react16.useMemo)(function() {
    return Kr(Xr, e5);
  }, [e5]);
};
var It = function(e5) {
  return "function" == typeof e5 ? e5 : "string" == typeof e5 ? 0 === e5.indexOf("time:") ? timeFormat(e5.slice("5")) : format(e5) : function(e6) {
    return "" + e6;
  };
};
var Dt = function(e5) {
  return (0, import_react16.useMemo)(function() {
    return It(e5);
  }, [e5]);
};
var Yt = (0, import_react16.createContext)();
var At = {};
var Ft = function(e5) {
  var r4 = e5.theme, t5 = void 0 === r4 ? At : r4, i4 = e5.children, n4 = Lt(t5);
  return (0, import_jsx_runtime2.jsx)(Yt.Provider, { value: n4, children: i4 });
};
Ft.propTypes = { children: import_prop_types.default.node.isRequired, theme: import_prop_types.default.object };
var Et = function() {
  return (0, import_react16.useContext)(Yt);
};
var Ut = function(e5) {
  var r4 = e5.children, t5 = e5.condition, i4 = e5.wrapper;
  return t5 ? (0, import_react16.cloneElement)(i4, {}, r4) : r4;
};
Ut.propTypes = { children: import_prop_types.default.node.isRequired, condition: import_prop_types.default.bool.isRequired, wrapper: import_prop_types.default.element.isRequired };
var Xt = { position: "relative" };
var Ht = function(e5) {
  var r4 = e5.children, t5 = e5.theme, n4 = e5.renderWrapper, o4 = void 0 === n4 || n4, a4 = e5.isInteractive, l3 = void 0 === a4 || a4, s4 = e5.animate, d3 = e5.motionConfig, u3 = (0, import_react16.useRef)(null);
  return (0, import_jsx_runtime2.jsx)(Ft, { theme: t5, children: (0, import_jsx_runtime2.jsx)(Vr, { animate: s4, config: d3, children: (0, import_jsx_runtime2.jsx)(M, { container: u3, children: (0, import_jsx_runtime2.jsxs)(Ut, { condition: o4, wrapper: (0, import_jsx_runtime2.jsx)("div", { style: Xt, ref: u3 }), children: [r4, l3 && (0, import_jsx_runtime2.jsx)(F, {})] }) }) }) });
};
Ht.propTypes = { children: import_prop_types.default.element.isRequired, isInteractive: import_prop_types.default.bool, renderWrapper: import_prop_types.default.bool, theme: import_prop_types.default.object, animate: import_prop_types.default.bool, motionConfig: import_prop_types.default.string };
var Kt = function() {
};
var Nt = { position: "relative" };
var Vt = function(e5) {
  var t5 = e5.children, n4 = e5.theme, o4 = e5.isInteractive, a4 = void 0 === o4 || o4, s4 = e5.renderWrapper, d3 = void 0 === s4 || s4, u3 = e5.animate, c9 = e5.motionConfig, f3 = (0, import_react16.useRef)(null), m4 = V(f3), y4 = m4.actions, v4 = m4.state, R = (0, import_react16.useCallback)(function(e6, r4) {
    return y4.showTooltipFromEvent(e6, r4);
  }, [y4.showTooltipFromEvent]), q2 = (0, import_react16.useMemo)(function() {
    return { showTooltip: a4 ? R : Kt, hideTooltip: a4 ? y4.hideTooltip : Kt };
  }, [y4.hideTooltip, a4, R]);
  return (0, import_jsx_runtime2.jsx)(Ft, { theme: n4, children: (0, import_jsx_runtime2.jsx)(Vr, { animate: u3, config: c9, children: (0, import_jsx_runtime2.jsx)(j.Provider, { value: y4, children: (0, import_jsx_runtime2.jsx)(O.Provider, { value: v4, children: (0, import_jsx_runtime2.jsxs)(Ut, { condition: d3, wrapper: (0, import_jsx_runtime2.jsx)("div", { style: Nt, ref: f3 }), children: [t5(q2), a4 && (0, import_jsx_runtime2.jsx)(F, {})] }) }) }) }) });
};
Vt.propTypes = { children: import_prop_types.default.func.isRequired, isInteractive: import_prop_types.default.bool, renderWrapper: import_prop_types.default.bool, theme: import_prop_types.default.object.isRequired, animate: import_prop_types.default.bool.isRequired, motionConfig: import_prop_types.default.string };
var Jt = function(e5) {
  var r4 = e5.children, t5 = Gt(), i4 = t5[0], n4 = t5[1], o4 = n4.width > 0 && n4.height > 0;
  return (0, import_jsx_runtime2.jsx)("div", { ref: i4, style: { width: "100%", height: "100%" }, children: o4 && r4({ width: n4.width, height: n4.height }) });
};
Jt.propTypes = { children: import_prop_types.default.func.isRequired };
var Qt = ["id", "colors"];
var Zt = function(e5) {
  var r4 = e5.id, t5 = e5.colors, i4 = jr(e5, Qt);
  return (0, import_jsx_runtime2.jsx)("linearGradient", Sr({ id: r4, x1: 0, x2: 0, y1: 0, y2: 1 }, i4, { children: t5.map(function(e6) {
    var r5 = e6.offset, t6 = e6.color, i5 = e6.opacity;
    return (0, import_jsx_runtime2.jsx)("stop", { offset: r5 + "%", stopColor: t6, stopOpacity: void 0 !== i5 ? i5 : 1 }, r5);
  }) }));
};
Zt.propTypes = { id: import_prop_types.default.string.isRequired, colors: import_prop_types.default.arrayOf(import_prop_types.default.shape({ offset: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, opacity: import_prop_types.default.number })).isRequired, gradientTransform: import_prop_types.default.string };
var ei = { linearGradient: Zt };
var ri = (0, import_react16.memo)(function(e5) {
  var r4 = e5.id, t5 = e5.background, i4 = e5.color, n4 = e5.size, o4 = e5.padding, a4 = e5.stagger, l3 = n4 + o4, s4 = n4 / 2, d3 = o4 / 2;
  return true === a4 && (l3 = 2 * n4 + 2 * o4), (0, import_jsx_runtime2.jsxs)("pattern", { id: r4, width: l3, height: l3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime2.jsx)("rect", { width: l3, height: l3, fill: t5 }), (0, import_jsx_runtime2.jsx)("circle", { cx: d3 + s4, cy: d3 + s4, r: s4, fill: i4 }), a4 && (0, import_jsx_runtime2.jsx)("circle", { cx: 1.5 * o4 + n4 + s4, cy: 1.5 * o4 + n4 + s4, r: s4, fill: i4 })] });
});
ri.displayName = "PatternDots", ri.propTypes = { id: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, background: import_prop_types.default.string.isRequired, size: import_prop_types.default.number.isRequired, padding: import_prop_types.default.number.isRequired, stagger: import_prop_types.default.bool.isRequired }, ri.defaultProps = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var ii = 2 * Math.PI;
var ni = function(e5) {
  return e5 * Math.PI / 180;
};
var hi = (0, import_react16.memo)(function(e5) {
  var r4 = e5.id, t5 = e5.spacing, i4 = e5.rotation, n4 = e5.background, o4 = e5.color, a4 = e5.lineWidth, l3 = Math.round(i4) % 360, s4 = Math.abs(t5);
  l3 > 180 ? l3 -= 360 : l3 > 90 ? l3 -= 180 : l3 < -180 ? l3 += 360 : l3 < -90 && (l3 += 180);
  var d3, u3 = s4, c9 = s4;
  return 0 === l3 ? d3 = "\n                M 0 0 L " + u3 + " 0\n                M 0 " + c9 + " L " + u3 + " " + c9 + "\n            " : 90 === l3 ? d3 = "\n                M 0 0 L 0 " + c9 + "\n                M " + u3 + " 0 L " + u3 + " " + c9 + "\n            " : (u3 = Math.abs(s4 / Math.sin(ni(l3))), c9 = s4 / Math.sin(ni(90 - l3)), d3 = l3 > 0 ? "\n                    M 0 " + -c9 + " L " + 2 * u3 + " " + c9 + "\n                    M " + -u3 + " " + -c9 + " L " + u3 + " " + c9 + "\n                    M " + -u3 + " 0 L " + u3 + " " + 2 * c9 + "\n                " : "\n                    M " + -u3 + " " + c9 + " L " + u3 + " " + -c9 + "\n                    M " + -u3 + " " + 2 * c9 + " L " + 2 * u3 + " " + -c9 + "\n                    M 0 " + 2 * c9 + " L " + 2 * u3 + " 0\n                "), (0, import_jsx_runtime2.jsxs)("pattern", { id: r4, width: u3, height: c9, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime2.jsx)("rect", { width: u3, height: c9, fill: n4, stroke: "rgba(255, 0, 0, 0.1)", strokeWidth: 0 }), (0, import_jsx_runtime2.jsx)("path", { d: d3, strokeWidth: a4, stroke: o4, strokeLinecap: "square" })] });
});
hi.displayName = "PatternLines", hi.propTypes = { id: import_prop_types.default.string.isRequired, spacing: import_prop_types.default.number.isRequired, rotation: import_prop_types.default.number.isRequired, background: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, lineWidth: import_prop_types.default.number.isRequired }, hi.defaultProps = { spacing: 5, rotation: 0, color: "#000000", background: "#ffffff", lineWidth: 2 };
var bi = (0, import_react16.memo)(function(e5) {
  var r4 = e5.id, t5 = e5.background, i4 = e5.color, n4 = e5.size, o4 = e5.padding, a4 = e5.stagger, l3 = n4 + o4, s4 = o4 / 2;
  return true === a4 && (l3 = 2 * n4 + 2 * o4), (0, import_jsx_runtime2.jsxs)("pattern", { id: r4, width: l3, height: l3, patternUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime2.jsx)("rect", { width: l3, height: l3, fill: t5 }), (0, import_jsx_runtime2.jsx)("rect", { x: s4, y: s4, width: n4, height: n4, fill: i4 }), a4 && (0, import_jsx_runtime2.jsx)("rect", { x: 1.5 * o4 + n4, y: 1.5 * o4 + n4, width: n4, height: n4, fill: i4 })] });
});
bi.displayName = "PatternSquares", bi.propTypes = { id: import_prop_types.default.string.isRequired, color: import_prop_types.default.string.isRequired, background: import_prop_types.default.string.isRequired, size: import_prop_types.default.number.isRequired, padding: import_prop_types.default.number.isRequired, stagger: import_prop_types.default.bool.isRequired }, bi.defaultProps = { color: "#000000", background: "#ffffff", size: 4, padding: 4, stagger: false };
var yi = { patternDots: ri, patternLines: hi, patternSquares: bi };
var vi = ["type"];
var Ri = Sr({}, ei, yi);
var qi = function(e5) {
  var r4 = e5.defs;
  return !r4 || r4.length < 1 ? null : (0, import_jsx_runtime2.jsx)("defs", { "aria-hidden": true, children: r4.map(function(e6) {
    var r5 = e6.type, t5 = jr(e6, vi);
    return Ri[r5] ? (0, import_react16.createElement)(Ri[r5], Sr({ key: t5.id }, t5)) : null;
  }) });
};
qi.propTypes = { defs: import_prop_types.default.arrayOf(import_prop_types.default.shape({ type: import_prop_types.default.oneOf(Object.keys(Ri)).isRequired, id: import_prop_types.default.string.isRequired })) };
var ki = (0, import_react16.memo)(qi);
var _i = function(e5) {
  var r4 = e5.width, t5 = e5.height, i4 = e5.margin, n4 = e5.defs, o4 = e5.children, a4 = e5.role, l3 = e5.ariaLabel, s4 = e5.ariaLabelledBy, d3 = e5.ariaDescribedBy, u3 = e5.isFocusable, c9 = Et();
  return (0, import_jsx_runtime2.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", width: r4, height: t5, role: a4, "aria-label": l3, "aria-labelledby": s4, "aria-describedby": d3, focusable: u3, tabIndex: u3 ? 0 : void 0, children: [(0, import_jsx_runtime2.jsx)(ki, { defs: n4 }), (0, import_jsx_runtime2.jsx)("rect", { width: r4, height: t5, fill: c9.background }), (0, import_jsx_runtime2.jsx)("g", { transform: "translate(" + i4.left + "," + i4.top + ")", children: o4 })] });
};
_i.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, margin: import_prop_types.default.shape({ top: import_prop_types.default.number.isRequired, left: import_prop_types.default.number.isRequired }).isRequired, defs: import_prop_types.default.array, children: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.node), import_prop_types.default.node]).isRequired, role: import_prop_types.default.string, isFocusable: import_prop_types.default.bool, ariaLabel: import_prop_types.default.string, ariaLabelledBy: import_prop_types.default.string, ariaDescribedBy: import_prop_types.default.string };
var wi = function(e5) {
  var r4 = e5.size, t5 = e5.color, i4 = e5.borderWidth, n4 = e5.borderColor;
  return (0, import_jsx_runtime2.jsx)("circle", { r: r4 / 2, fill: t5, stroke: n4, strokeWidth: i4, style: { pointerEvents: "none" } });
};
wi.propTypes = { size: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, borderWidth: import_prop_types.default.number.isRequired, borderColor: import_prop_types.default.string.isRequired };
var xi = (0, import_react16.memo)(wi);
var Oi = function(e5) {
  var r4 = e5.x, t5 = e5.y, i4 = e5.symbol, n4 = void 0 === i4 ? xi : i4, o4 = e5.size, a4 = e5.datum, l3 = e5.color, s4 = e5.borderWidth, u3 = e5.borderColor, c9 = e5.label, f3 = e5.labelTextAnchor, p3 = void 0 === f3 ? "middle" : f3, h2 = e5.labelYOffset, g3 = void 0 === h2 ? -12 : h2, b3 = Et(), m4 = Zr(), y4 = m4.animate, v4 = m4.config, R = useSpring({ transform: "translate(" + r4 + ", " + t5 + ")", config: v4, immediate: !y4 });
  return (0, import_jsx_runtime2.jsxs)(animated.g, { transform: R.transform, style: { pointerEvents: "none" }, children: [(0, import_react16.createElement)(n4, { size: o4, color: l3, datum: a4, borderWidth: s4, borderColor: u3 }), c9 && (0, import_jsx_runtime2.jsx)("text", { textAnchor: p3, y: g3, style: b3.dots.text, children: c9 })] });
};
Oi.propTypes = { x: import_prop_types.default.number.isRequired, y: import_prop_types.default.number.isRequired, datum: import_prop_types.default.object.isRequired, size: import_prop_types.default.number.isRequired, color: import_prop_types.default.string.isRequired, borderWidth: import_prop_types.default.number.isRequired, borderColor: import_prop_types.default.string.isRequired, symbol: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]), label: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number]), labelTextAnchor: import_prop_types.default.oneOf(["start", "middle", "end"]), labelYOffset: import_prop_types.default.number };
var Wi = (0, import_react16.memo)(Oi);
var Ci = function(e5) {
  var r4 = e5.width, t5 = e5.height, i4 = e5.axis, n4 = e5.scale, o4 = e5.value, a4 = e5.lineStyle, l3 = e5.textStyle, s4 = e5.legend, d3 = e5.legendPosition, u3 = e5.legendOffsetX, c9 = e5.legendOffsetY, f3 = e5.legendOrientation, p3 = Et(), h2 = 0, g3 = 0, b3 = 0, m4 = 0;
  "y" === i4 ? (b3 = n4(o4), g3 = r4) : (h2 = n4(o4), m4 = t5);
  var y4 = null;
  if (s4) {
    var v4 = function(e6) {
      var r5 = e6.axis, t6 = e6.width, i5 = e6.height, n5 = e6.position, o5 = e6.offsetX, a5 = e6.offsetY, l4 = e6.orientation, s5 = 0, d4 = 0, u4 = "vertical" === l4 ? -90 : 0, c10 = "start";
      if ("x" === r5) switch (n5) {
        case "top-left":
          s5 = -o5, d4 = a5, c10 = "end";
          break;
        case "top":
          d4 = -a5, c10 = "horizontal" === l4 ? "middle" : "start";
          break;
        case "top-right":
          s5 = o5, d4 = a5, c10 = "horizontal" === l4 ? "start" : "end";
          break;
        case "right":
          s5 = o5, d4 = i5 / 2, c10 = "horizontal" === l4 ? "start" : "middle";
          break;
        case "bottom-right":
          s5 = o5, d4 = i5 - a5, c10 = "start";
          break;
        case "bottom":
          d4 = i5 + a5, c10 = "horizontal" === l4 ? "middle" : "end";
          break;
        case "bottom-left":
          d4 = i5 - a5, s5 = -o5, c10 = "horizontal" === l4 ? "end" : "start";
          break;
        case "left":
          s5 = -o5, d4 = i5 / 2, c10 = "horizontal" === l4 ? "end" : "middle";
      }
      else switch (n5) {
        case "top-left":
          s5 = o5, d4 = -a5, c10 = "start";
          break;
        case "top":
          s5 = t6 / 2, d4 = -a5, c10 = "horizontal" === l4 ? "middle" : "start";
          break;
        case "top-right":
          s5 = t6 - o5, d4 = -a5, c10 = "horizontal" === l4 ? "end" : "start";
          break;
        case "right":
          s5 = t6 + o5, c10 = "horizontal" === l4 ? "start" : "middle";
          break;
        case "bottom-right":
          s5 = t6 - o5, d4 = a5, c10 = "end";
          break;
        case "bottom":
          s5 = t6 / 2, d4 = a5, c10 = "horizontal" === l4 ? "middle" : "end";
          break;
        case "bottom-left":
          s5 = o5, d4 = a5, c10 = "horizontal" === l4 ? "start" : "end";
          break;
        case "left":
          s5 = -o5, c10 = "horizontal" === l4 ? "end" : "middle";
      }
      return { x: s5, y: d4, rotation: u4, textAnchor: c10 };
    }({ axis: i4, width: r4, height: t5, position: d3, offsetX: u3, offsetY: c9, orientation: f3 });
    y4 = (0, import_jsx_runtime2.jsx)("text", { transform: "translate(" + v4.x + ", " + v4.y + ") rotate(" + v4.rotation + ")", textAnchor: v4.textAnchor, dominantBaseline: "central", style: l3, children: s4 });
  }
  return (0, import_jsx_runtime2.jsxs)("g", { transform: "translate(" + h2 + ", " + b3 + ")", children: [(0, import_jsx_runtime2.jsx)("line", { x1: 0, x2: g3, y1: 0, y2: m4, stroke: p3.markers.lineColor, strokeWidth: p3.markers.lineStrokeWidth, style: a4 }), y4] });
};
Ci.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, axis: import_prop_types.default.oneOf(["x", "y"]).isRequired, scale: import_prop_types.default.func.isRequired, value: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.instanceOf(Date)]).isRequired, lineStyle: import_prop_types.default.object, textStyle: import_prop_types.default.object, legend: import_prop_types.default.string, legendPosition: import_prop_types.default.oneOf(["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"]), legendOffsetX: import_prop_types.default.number.isRequired, legendOffsetY: import_prop_types.default.number.isRequired, legendOrientation: import_prop_types.default.oneOf(["horizontal", "vertical"]).isRequired }, Ci.defaultProps = { legendPosition: "top-right", legendOffsetX: 14, legendOffsetY: 14, legendOrientation: "horizontal" };
var zi = (0, import_react16.memo)(Ci);
var Pi = function(e5) {
  var r4 = e5.markers, t5 = e5.width, i4 = e5.height, n4 = e5.xScale, o4 = e5.yScale;
  return r4 && 0 !== r4.length ? r4.map(function(e6, r5) {
    return (0, import_jsx_runtime2.jsx)(zi, Sr({}, e6, { width: t5, height: i4, scale: "y" === e6.axis ? o4 : n4 }), r5);
  }) : null;
};
Pi.propTypes = { width: import_prop_types.default.number.isRequired, height: import_prop_types.default.number.isRequired, xScale: import_prop_types.default.func.isRequired, yScale: import_prop_types.default.func.isRequired, markers: import_prop_types.default.arrayOf(import_prop_types.default.shape({ axis: import_prop_types.default.oneOf(["x", "y"]).isRequired, value: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string, import_prop_types.default.instanceOf(Date)]).isRequired, lineStyle: import_prop_types.default.object, textStyle: import_prop_types.default.object })) };
var Ti = (0, import_react16.memo)(Pi);
var Bi = function(e5) {
  return (0, import_isFunction.default)(e5) ? e5 : function(r4) {
    return (0, import_get.default)(r4, e5);
  };
};
var Gi = function(e5) {
  return (0, import_react16.useMemo)(function() {
    return Bi(e5);
  }, [e5]);
};
var Ei = Object.keys(ei);
var Ui = Object.keys(yi);

// node_modules/@nivo/legends/dist/nivo-legends.es.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@nivo/colors/dist/nivo-colors.es.js
var import_react17 = __toESM(require_react());
var import_get2 = __toESM(require_get());
var import_isPlainObject2 = __toESM(require_isPlainObject());
var import_prop_types2 = __toESM(require_prop_types());
function qe() {
  return qe = Object.assign ? Object.assign.bind() : function(e5) {
    for (var r4 = 1; r4 < arguments.length; r4++) {
      var n4 = arguments[r4];
      for (var t5 in n4) Object.prototype.hasOwnProperty.call(n4, t5) && (e5[t5] = n4[t5]);
    }
    return e5;
  }, qe.apply(this, arguments);
}
function Se(e5, r4) {
  (null == r4 || r4 > e5.length) && (r4 = e5.length);
  for (var n4 = 0, t5 = new Array(r4); n4 < r4; n4++) t5[n4] = e5[n4];
  return t5;
}
function Re(e5, r4) {
  var n4 = "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
  if (n4) return (n4 = n4.call(e5)).next.bind(n4);
  if (Array.isArray(e5) || (n4 = function(e6, r5) {
    if (e6) {
      if ("string" == typeof e6) return Se(e6, r5);
      var n5 = Object.prototype.toString.call(e6).slice(8, -1);
      return "Object" === n5 && e6.constructor && (n5 = e6.constructor.name), "Map" === n5 || "Set" === n5 ? Array.from(e6) : "Arguments" === n5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5) ? Se(e6, r5) : void 0;
    }
  }(e5)) || r4 && e5 && "number" == typeof e5.length) {
    n4 && (e5 = n4);
    var t5 = 0;
    return function() {
      return t5 >= e5.length ? { done: true } : { done: false, value: e5[t5++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var Ce = { nivo: ["#e8c1a0", "#f47560", "#f1e15b", "#e8a838", "#61cdbb", "#97e3d5"], category10: category10_default, accent: Accent_default, dark2: Dark2_default, paired: Paired_default, pastel1: Pastel1_default, pastel2: Pastel2_default, set1: Set1_default, set2: Set2_default, set3: Set3_default };
var Ge = Object.keys(Ce);
var Ve = { brown_blueGreen: scheme, purpleRed_green: scheme2, pink_yellowGreen: scheme3, purple_orange: scheme4, red_blue: scheme5, red_grey: scheme6, red_yellow_blue: scheme7, red_yellow_green: scheme8, spectral: scheme9 };
var Te = Object.keys(Ve);
var Pe = { brown_blueGreen: BrBG_default, purpleRed_green: PRGn_default, pink_yellowGreen: PiYG_default, purple_orange: PuOr_default, red_blue: RdBu_default, red_grey: RdGy_default, red_yellow_blue: RdYlBu_default, red_yellow_green: RdYlGn_default, spectral: Spectral_default };
var Ue = { blues: scheme22, greens: scheme23, greys: scheme24, oranges: scheme27, purples: scheme25, reds: scheme26, blue_green: scheme10, blue_purple: scheme11, green_blue: scheme12, orange_red: scheme13, purple_blue_green: scheme14, purple_blue: scheme15, purple_red: scheme16, red_purple: scheme17, yellow_green_blue: scheme18, yellow_green: scheme19, yellow_orange_brown: scheme20, yellow_orange_red: scheme21 };
var De = Object.keys(Ue);
var Me = { blues: Blues_default, greens: Greens_default, greys: Greys_default, oranges: Oranges_default, purples: Purples_default, reds: Reds_default, turbo: turbo_default, viridis: viridis_default, inferno, magma, plasma, cividis: cividis_default, warm, cool, cubehelixDefault: cubehelix_default, blue_green: BuGn_default, blue_purple: BuPu_default, green_blue: GnBu_default, orange_red: OrRd_default, purple_blue_green: PuBuGn_default, purple_blue: PuBu_default, purple_red: PuRd_default, red_purple: RdPu_default, yellow_green_blue: YlGnBu_default, yellow_green: YlGn_default, yellow_orange_brown: YlOrBr_default, yellow_orange_red: YlOrRd_default };
var $e = qe({}, Ce, Ve, Ue);
var Be = Object.keys($e);
var Fe = function(e5) {
  return Ge.includes(e5);
};
var He = function(e5) {
  return Te.includes(e5);
};
var Je = function(e5) {
  return De.includes(e5);
};
var Ke = { rainbow: rainbow_default, sinebow: sinebow_default };
var Le = qe({}, Pe, Me, Ke);
var Ne = Object.keys(Le);
var Qe2 = function(e5, r4) {
  if ("function" == typeof e5) return e5;
  if ((0, import_isPlainObject2.default)(e5)) {
    if (function(e6) {
      return void 0 !== e6.theme;
    }(e5)) {
      if (void 0 === r4) throw new Error("Unable to use color from theme as no theme was provided");
      var n4 = (0, import_get2.default)(r4, e5.theme);
      if (void 0 === n4) throw new Error("Color from theme is undefined at path: '" + e5.theme + "'");
      return function() {
        return n4;
      };
    }
    if (function(e6) {
      return void 0 !== e6.from;
    }(e5)) {
      var t5 = function(r5) {
        return (0, import_get2.default)(r5, e5.from);
      };
      if (Array.isArray(e5.modifiers)) {
        for (var o4, i4 = [], u3 = function() {
          var e6 = o4.value, r5 = e6[0], n5 = e6[1];
          if ("brighter" === r5) i4.push(function(e7) {
            return e7.brighter(n5);
          });
          else if ("darker" === r5) i4.push(function(e7) {
            return e7.darker(n5);
          });
          else {
            if ("opacity" !== r5) throw new Error("Invalid color modifier: '" + r5 + "', must be one of: 'brighter', 'darker', 'opacity'");
            i4.push(function(e7) {
              return e7.opacity = n5, e7;
            });
          }
        }, a4 = Re(e5.modifiers); !(o4 = a4()).done; ) u3();
        return 0 === i4.length ? t5 : function(e6) {
          return i4.reduce(function(e7, r5) {
            return r5(e7);
          }, rgb(t5(e6))).toString();
        };
      }
      return t5;
    }
    throw new Error("Invalid color spec, you should either specify 'theme' or 'from' when using a config object");
  }
  return function() {
    return e5;
  };
};
var We = function(e5, r4) {
  return (0, import_react17.useMemo)(function() {
    return Qe2(e5, r4);
  }, [e5, r4]);
};
var Xe = import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.arrayOf(import_prop_types2.default.string), import_prop_types2.default.shape({ scheme: import_prop_types2.default.oneOf(Be).isRequired, size: import_prop_types2.default.number }), import_prop_types2.default.shape({ datum: import_prop_types2.default.string.isRequired }), import_prop_types2.default.string]);
var Ye = import_prop_types2.default.oneOfType([import_prop_types2.default.string, import_prop_types2.default.func, import_prop_types2.default.shape({ theme: import_prop_types2.default.string.isRequired }), import_prop_types2.default.shape({ from: import_prop_types2.default.string.isRequired, modifiers: import_prop_types2.default.arrayOf(import_prop_types2.default.array) })]);
var fr = function(e5, r4) {
  if ("function" == typeof e5) return e5;
  var n4 = "function" == typeof r4 ? r4 : function(e6) {
    return (0, import_get2.default)(e6, r4);
  };
  if (Array.isArray(e5)) {
    var t5 = ordinal(e5), o4 = function(e6) {
      return t5(n4(e6));
    };
    return o4.scale = t5, o4;
  }
  if ((0, import_isPlainObject2.default)(e5)) {
    if (function(e6) {
      return void 0 !== e6.datum;
    }(e5)) return function(r5) {
      return (0, import_get2.default)(r5, e5.datum);
    };
    if (function(e6) {
      return void 0 !== e6.scheme;
    }(e5)) {
      if (Fe(e5.scheme)) {
        var i4 = ordinal($e[e5.scheme]), u3 = function(e6) {
          return i4(n4(e6));
        };
        return u3.scale = i4, u3;
      }
      if (He(e5.scheme)) {
        if (void 0 !== e5.size && (e5.size < 3 || e5.size > 11)) throw new Error("Invalid size '" + e5.size + "' for diverging color scheme '" + e5.scheme + "', must be between 3~11");
        var a4 = ordinal($e[e5.scheme][e5.size || 11]), l3 = function(e6) {
          return a4(n4(e6));
        };
        return l3.scale = a4, l3;
      }
      if (Je(e5.scheme)) {
        if (void 0 !== e5.size && (e5.size < 3 || e5.size > 9)) throw new Error("Invalid size '" + e5.size + "' for sequential color scheme '" + e5.scheme + "', must be between 3~9");
        var s4 = ordinal($e[e5.scheme][e5.size || 9]), c9 = function(e6) {
          return s4(n4(e6));
        };
        return c9.scale = s4, c9;
      }
    }
    throw new Error("Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property");
  }
  return function() {
    return e5;
  };
};
var pr = function(e5, r4) {
  return (0, import_react17.useMemo)(function() {
    return fr(e5, r4);
  }, [e5, r4]);
};

// node_modules/@nivo/legends/dist/nivo-legends.es.js
var a3 = __toESM(require_react());
var import_react18 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
var m3 = function(e5) {
  var i4 = e5.x, n4 = e5.y, o4 = e5.size, r4 = e5.fill, l3 = e5.opacity, a4 = void 0 === l3 ? 1 : l3, c9 = e5.borderWidth, s4 = void 0 === c9 ? 0 : c9, d3 = e5.borderColor;
  return (0, import_jsx_runtime3.jsx)("circle", { r: o4 / 2, cx: i4 + o4 / 2, cy: n4 + o4 / 2, fill: r4, opacity: a4, strokeWidth: s4, stroke: void 0 === d3 ? "transparent" : d3, style: { pointerEvents: "none" } });
};
var f2 = function(e5) {
  var i4 = e5.x, n4 = e5.y, o4 = e5.size, r4 = e5.fill, l3 = e5.opacity, a4 = void 0 === l3 ? 1 : l3, c9 = e5.borderWidth, s4 = void 0 === c9 ? 0 : c9, d3 = e5.borderColor;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + i4 + "," + n4 + ")", children: (0, import_jsx_runtime3.jsx)("path", { d: "\n                    M" + o4 / 2 + " 0\n                    L" + 0.8 * o4 + " " + o4 / 2 + "\n                    L" + o4 / 2 + " " + o4 + "\n                    L" + 0.2 * o4 + " " + o4 / 2 + "\n                    L" + o4 / 2 + " 0\n                ", fill: r4, opacity: a4, strokeWidth: s4, stroke: void 0 === d3 ? "transparent" : d3, style: { pointerEvents: "none" } }) });
};
var u2 = function(e5) {
  var i4 = e5.x, n4 = e5.y, o4 = e5.size, r4 = e5.fill, l3 = e5.opacity, a4 = void 0 === l3 ? 1 : l3, c9 = e5.borderWidth, s4 = void 0 === c9 ? 0 : c9, d3 = e5.borderColor;
  return (0, import_jsx_runtime3.jsx)("rect", { x: i4, y: n4, fill: r4, opacity: a4, strokeWidth: s4, stroke: void 0 === d3 ? "transparent" : d3, width: o4, height: o4, style: { pointerEvents: "none" } });
};
var v3 = function(e5) {
  var i4 = e5.x, n4 = e5.y, o4 = e5.size, r4 = e5.fill, l3 = e5.opacity, a4 = void 0 === l3 ? 1 : l3, c9 = e5.borderWidth, s4 = void 0 === c9 ? 0 : c9, d3 = e5.borderColor;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + i4 + "," + n4 + ")", children: (0, import_jsx_runtime3.jsx)("path", { d: "\n                M" + o4 / 2 + " 0\n                L" + o4 + " " + o4 + "\n                L0 " + o4 + "\n                L" + o4 / 2 + " 0\n            ", fill: r4, opacity: a4, strokeWidth: s4, stroke: void 0 === d3 ? "transparent" : d3, style: { pointerEvents: "none" } }) });
};
function p2() {
  return p2 = Object.assign ? Object.assign.bind() : function(t5) {
    for (var e5 = 1; e5 < arguments.length; e5++) {
      var i4 = arguments[e5];
      for (var n4 in i4) Object.prototype.hasOwnProperty.call(i4, n4) && (t5[n4] = i4[n4]);
    }
    return t5;
  }, p2.apply(this, arguments);
}
var b2 = { top: 0, right: 0, bottom: 0, left: 0 };
var k3 = function(t5) {
  var e5, i4 = t5.direction, n4 = t5.itemsSpacing, o4 = t5.padding, r4 = t5.itemCount, l3 = t5.itemWidth, a4 = t5.itemHeight;
  if ("number" != typeof o4 && ("object" != typeof (e5 = o4) || Array.isArray(e5) || null === e5)) throw new Error("Invalid property padding, must be one of: number, object");
  var c9 = "number" == typeof o4 ? { top: o4, right: o4, bottom: o4, left: o4 } : p2({}, b2, o4), s4 = c9.left + c9.right, d3 = c9.top + c9.bottom, h2 = l3 + s4, g3 = a4 + d3, m4 = (r4 - 1) * n4;
  return "row" === i4 ? h2 = l3 * r4 + m4 + s4 : "column" === i4 && (g3 = a4 * r4 + m4 + d3), { width: h2, height: g3, padding: c9 };
};
var x4 = function(t5) {
  var e5 = t5.anchor, i4 = t5.translateX, n4 = t5.translateY, o4 = t5.containerWidth, r4 = t5.containerHeight, l3 = t5.width, a4 = t5.height, c9 = i4, s4 = n4;
  switch (e5) {
    case "top":
      c9 += (o4 - l3) / 2;
      break;
    case "top-right":
      c9 += o4 - l3;
      break;
    case "right":
      c9 += o4 - l3, s4 += (r4 - a4) / 2;
      break;
    case "bottom-right":
      c9 += o4 - l3, s4 += r4 - a4;
      break;
    case "bottom":
      c9 += (o4 - l3) / 2, s4 += r4 - a4;
      break;
    case "bottom-left":
      s4 += r4 - a4;
      break;
    case "left":
      s4 += (r4 - a4) / 2;
      break;
    case "center":
      c9 += (o4 - l3) / 2, s4 += (r4 - a4) / 2;
  }
  return { x: c9, y: s4 };
};
var S = function(t5) {
  var e5, i4, n4, o4, r4, l3, a4 = t5.direction, c9 = t5.justify, s4 = t5.symbolSize, d3 = t5.symbolSpacing, h2 = t5.width, g3 = t5.height;
  switch (a4) {
    case "left-to-right":
      e5 = 0, i4 = (g3 - s4) / 2, o4 = g3 / 2, l3 = "central", c9 ? (n4 = h2, r4 = "end") : (n4 = s4 + d3, r4 = "start");
      break;
    case "right-to-left":
      e5 = h2 - s4, i4 = (g3 - s4) / 2, o4 = g3 / 2, l3 = "central", c9 ? (n4 = 0, r4 = "start") : (n4 = h2 - s4 - d3, r4 = "end");
      break;
    case "top-to-bottom":
      e5 = (h2 - s4) / 2, i4 = 0, n4 = h2 / 2, r4 = "middle", c9 ? (o4 = g3, l3 = "alphabetic") : (o4 = s4 + d3, l3 = "text-before-edge");
      break;
    case "bottom-to-top":
      e5 = (h2 - s4) / 2, i4 = g3 - s4, n4 = h2 / 2, r4 = "middle", c9 ? (o4 = 0, l3 = "text-before-edge") : (o4 = g3 - s4 - d3, l3 = "alphabetic");
  }
  return { symbolX: e5, symbolY: i4, labelX: n4, labelY: o4, labelAnchor: r4, labelAlignment: l3 };
};
var C3 = { circle: m3, diamond: f2, square: u2, triangle: v3 };
var B = function(i4) {
  var n4, r4, l3, c9, h2, g3, m4, f3, u3, v4, y4, b3 = i4.x, k4 = i4.y, x5 = i4.width, A3 = i4.height, W2 = i4.data, O3 = i4.direction, z4 = void 0 === O3 ? "left-to-right" : O3, B2 = i4.justify, w4 = void 0 !== B2 && B2, X3 = i4.textColor, Y2 = i4.background, H = void 0 === Y2 ? "transparent" : Y2, E3 = i4.opacity, j3 = void 0 === E3 ? 1 : E3, T4 = i4.symbolShape, L2 = void 0 === T4 ? "square" : T4, M3 = i4.symbolSize, F2 = void 0 === M3 ? 16 : M3, P2 = i4.symbolSpacing, R = void 0 === P2 ? 8 : P2, q2 = i4.symbolBorderWidth, V3 = void 0 === q2 ? 0 : q2, D2 = i4.symbolBorderColor, G2 = void 0 === D2 ? "transparent" : D2, I = i4.onClick, N2 = i4.onMouseEnter, _2 = i4.onMouseLeave, J2 = i4.toggleSerie, K2 = i4.effects, Q2 = (0, import_react18.useState)({}), U2 = Q2[0], Z2 = Q2[1], $2 = Et(), tt = (0, import_react18.useCallback)(function(t5) {
    if (K2) {
      var e5 = K2.filter(function(t6) {
        return "hover" === t6.on;
      }).reduce(function(t6, e6) {
        return p2({}, t6, e6.style);
      }, {});
      Z2(e5);
    }
    null == N2 || N2(W2, t5);
  }, [N2, W2, K2]), et2 = (0, import_react18.useCallback)(function(t5) {
    if (K2) {
      var e5 = K2.filter(function(t6) {
        return "hover" !== t6.on;
      }).reduce(function(t6, e6) {
        return p2({}, t6, e6.style);
      }, {});
      Z2(e5);
    }
    null == _2 || _2(W2, t5);
  }, [_2, W2, K2]), it2 = S({ direction: z4, justify: w4, symbolSize: null != (n4 = U2.symbolSize) ? n4 : F2, symbolSpacing: R, width: x5, height: A3 }), nt = it2.symbolX, ot = it2.symbolY, rt2 = it2.labelX, lt = it2.labelY, at = it2.labelAnchor, ct2 = it2.labelAlignment, st = [I, N2, _2, J2].some(function(t5) {
    return void 0 !== t5;
  }), dt2 = "function" == typeof L2 ? L2 : C3[L2];
  return (0, import_jsx_runtime3.jsxs)("g", { transform: "translate(" + b3 + "," + k4 + ")", style: { opacity: null != (r4 = U2.itemOpacity) ? r4 : j3 }, children: [(0, import_jsx_runtime3.jsx)("rect", { width: x5, height: A3, fill: null != (l3 = U2.itemBackground) ? l3 : H, style: { cursor: st ? "pointer" : "auto" }, onClick: function(t5) {
    null == I || I(W2, t5), null == J2 || J2(W2.id);
  }, onMouseEnter: tt, onMouseLeave: et2 }), a3.createElement(dt2, p2({ id: W2.id, x: nt, y: ot, size: null != (c9 = U2.symbolSize) ? c9 : F2, fill: null != (h2 = null != (g3 = W2.fill) ? g3 : W2.color) ? h2 : "black", borderWidth: null != (m4 = U2.symbolBorderWidth) ? m4 : V3, borderColor: null != (f3 = U2.symbolBorderColor) ? f3 : G2 }, W2.hidden ? $2.legends.hidden.symbol : void 0)), (0, import_jsx_runtime3.jsx)("text", { textAnchor: at, style: p2({}, $2.legends.text, { fill: null != (u3 = null != (v4 = null != (y4 = U2.itemTextColor) ? y4 : X3) ? v4 : $2.legends.text.fill) ? u3 : "black", dominantBaseline: ct2, pointerEvents: "none", userSelect: "none" }, W2.hidden ? $2.legends.hidden.text : void 0), x: rt2, y: lt, children: W2.label })] });
};
var w2 = function(e5) {
  var i4 = e5.data, n4 = e5.x, o4 = e5.y, r4 = e5.direction, l3 = e5.padding, a4 = void 0 === l3 ? 0 : l3, c9 = e5.justify, s4 = e5.effects, d3 = e5.itemWidth, h2 = e5.itemHeight, g3 = e5.itemDirection, m4 = void 0 === g3 ? "left-to-right" : g3, f3 = e5.itemsSpacing, u3 = void 0 === f3 ? 0 : f3, v4 = e5.itemTextColor, p3 = e5.itemBackground, y4 = void 0 === p3 ? "transparent" : p3, b3 = e5.itemOpacity, x5 = void 0 === b3 ? 1 : b3, S3 = e5.symbolShape, A3 = e5.symbolSize, W2 = e5.symbolSpacing, O3 = e5.symbolBorderWidth, z4 = e5.symbolBorderColor, C4 = e5.onClick, w4 = e5.onMouseEnter, X3 = e5.onMouseLeave, Y2 = e5.toggleSerie, H = k3({ itemCount: i4.length, itemWidth: d3, itemHeight: h2, itemsSpacing: u3, direction: r4, padding: a4 }).padding, E3 = "row" === r4 ? d3 + u3 : 0, j3 = "column" === r4 ? h2 + u3 : 0;
  return (0, import_jsx_runtime3.jsx)("g", { transform: "translate(" + n4 + "," + o4 + ")", children: i4.map(function(e6, i5) {
    return (0, import_jsx_runtime3.jsx)(B, { data: e6, x: i5 * E3 + H.left, y: i5 * j3 + H.top, width: d3, height: h2, direction: m4, justify: c9, effects: s4, textColor: v4, background: y4, opacity: x5, symbolShape: S3, symbolSize: A3, symbolSpacing: W2, symbolBorderWidth: O3, symbolBorderColor: z4, onClick: C4, onMouseEnter: w4, onMouseLeave: X3, toggleSerie: Y2 }, i5);
  }) });
};
var X = function(e5) {
  var i4 = e5.data, n4 = e5.containerWidth, o4 = e5.containerHeight, r4 = e5.translateX, l3 = void 0 === r4 ? 0 : r4, a4 = e5.translateY, c9 = void 0 === a4 ? 0 : a4, s4 = e5.anchor, d3 = e5.direction, h2 = e5.padding, g3 = void 0 === h2 ? 0 : h2, m4 = e5.justify, f3 = e5.itemsSpacing, u3 = void 0 === f3 ? 0 : f3, v4 = e5.itemWidth, p3 = e5.itemHeight, y4 = e5.itemDirection, b3 = e5.itemTextColor, S3 = e5.itemBackground, A3 = e5.itemOpacity, W2 = e5.symbolShape, O3 = e5.symbolSize, z4 = e5.symbolSpacing, C4 = e5.symbolBorderWidth, B2 = e5.symbolBorderColor, X3 = e5.onClick, Y2 = e5.onMouseEnter, H = e5.onMouseLeave, E3 = e5.toggleSerie, j3 = e5.effects, T4 = k3({ itemCount: i4.length, itemsSpacing: u3, itemWidth: v4, itemHeight: p3, direction: d3, padding: g3 }), L2 = T4.width, M3 = T4.height, F2 = x4({ anchor: s4, translateX: l3, translateY: c9, containerWidth: n4, containerHeight: o4, width: L2, height: M3 }), P2 = F2.x, R = F2.y;
  return (0, import_jsx_runtime3.jsx)(w2, { data: i4, x: P2, y: R, direction: d3, padding: g3, justify: m4, effects: j3, itemsSpacing: u3, itemWidth: v4, itemHeight: p3, itemDirection: y4, itemTextColor: b3, itemBackground: S3, itemOpacity: A3, symbolShape: W2, symbolSize: O3, symbolSpacing: z4, symbolBorderWidth: C4, symbolBorderColor: B2, onClick: X3, onMouseEnter: Y2, onMouseLeave: H, toggleSerie: "boolean" == typeof E3 ? void 0 : E3 });
};
var T2 = { data: import_prop_types3.default.arrayOf(import_prop_types3.default.object), anchor: import_prop_types3.default.oneOf(["top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", "center"]).isRequired, translateX: import_prop_types3.default.number, translateY: import_prop_types3.default.number, direction: import_prop_types3.default.oneOf(["row", "column"]).isRequired, itemsSpacing: import_prop_types3.default.number, itemWidth: import_prop_types3.default.number.isRequired, itemHeight: import_prop_types3.default.number.isRequired, itemDirection: import_prop_types3.default.oneOf(["left-to-right", "right-to-left", "top-to-bottom", "bottom-to-top"]), itemTextColor: import_prop_types3.default.string, itemBackground: import_prop_types3.default.string, itemOpacity: import_prop_types3.default.number, symbolShape: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["circle", "diamond", "square", "triangle"]), import_prop_types3.default.func]), symbolSize: import_prop_types3.default.number, symbolSpacing: import_prop_types3.default.number, symbolBorderWidth: import_prop_types3.default.number, symbolBorderColor: import_prop_types3.default.string, onClick: import_prop_types3.default.func, onMouseEnter: import_prop_types3.default.func, onMouseLeave: import_prop_types3.default.func, effects: import_prop_types3.default.arrayOf(import_prop_types3.default.shape({ on: import_prop_types3.default.oneOfType([import_prop_types3.default.oneOf(["hover"])]).isRequired, style: import_prop_types3.default.shape({ itemTextColor: import_prop_types3.default.string, itemBackground: import_prop_types3.default.string, itemOpacity: import_prop_types3.default.number, symbolSize: import_prop_types3.default.number, symbolBorderWidth: import_prop_types3.default.number, symbolBorderColor: import_prop_types3.default.string }).isRequired })) };

// node_modules/d3-sankey/src/align.js
function targetDepth(d3) {
  return d3.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n4) {
  return n4 - 1 - node.height;
}
function justify(node, n4) {
  return node.sourceLinks.length ? node.depth : n4 - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;
}

// node_modules/d3-sankey/src/constant.js
function constant(x5) {
  return function() {
    return x5;
  };
}

// node_modules/d3-sankey/src/sankey.js
function ascendingSourceBreadth(a4, b3) {
  return ascendingBreadth(a4.source, b3.source) || a4.index - b3.index;
}
function ascendingTargetBreadth(a4, b3) {
  return ascendingBreadth(a4.target, b3.target) || a4.index - b3.index;
}
function ascendingBreadth(a4, b3) {
  return a4.y0 - b3.y0;
}
function value(d3) {
  return d3.value;
}
function defaultId(d3) {
  return d3.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id) {
  const node = nodeById.get(id);
  if (!node) throw new Error("missing: " + id);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link of node.sourceLinks) {
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (const link of node.targetLinks) {
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id = defaultId;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_2) {
    return arguments.length ? (id = typeof _2 === "function" ? _2 : constant(_2), sankey) : id;
  };
  sankey.nodeAlign = function(_2) {
    return arguments.length ? (align = typeof _2 === "function" ? _2 : constant(_2), sankey) : align;
  };
  sankey.nodeSort = function(_2) {
    return arguments.length ? (sort = _2, sankey) : sort;
  };
  sankey.nodeWidth = function(_2) {
    return arguments.length ? (dx = +_2, sankey) : dx;
  };
  sankey.nodePadding = function(_2) {
    return arguments.length ? (dy = py = +_2, sankey) : dy;
  };
  sankey.nodes = function(_2) {
    return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant(_2), sankey) : nodes;
  };
  sankey.links = function(_2) {
    return arguments.length ? (links = typeof _2 === "function" ? _2 : constant(_2), sankey) : links;
  };
  sankey.linkSort = function(_2) {
    return arguments.length ? (linkSort = _2, sankey) : linkSort;
  };
  sankey.size = function(_2) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_2[0], y1 = +_2[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_2) {
    return arguments.length ? (x0 = +_2[0][0], x1 = +_2[1][0], y0 = +_2[0][1], y1 = +_2[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_2) {
    return arguments.length ? (iterations = +_2, sankey) : iterations;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    for (const [i4, node] of nodes2.entries()) {
      node.index = i4;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d3, i4) => [id(d3, i4, nodes2), d3]));
    for (const [i4, link] of links2.entries()) {
      link.index = i4;
      let { source, target } = link;
      if (typeof source !== "object") source = link.source = find(nodeById, source);
      if (typeof target !== "object") target = link.target = find(nodeById, target);
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n4 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x5 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x5;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x5 > n4) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n4 = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x5 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x5;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x5 > n4) throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x5 = max(nodes2, (d3) => d3.depth) + 1;
    const kx2 = (x1 - x0 - dx) / (x5 - 1);
    const columns = new Array(x5);
    for (const node of nodes2) {
      const i4 = Math.max(0, Math.min(x5 - 1, Math.floor(align.call(null, node, x5))));
      node.layer = i4;
      node.x0 = x0 + i4 * kx2;
      node.x1 = node.x0 + dx;
      if (columns[i4]) columns[i4].push(node);
      else columns[i4] = [node];
    }
    if (sort) for (const column of columns) {
      column.sort(sort);
    }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky2 = min(columns, (c9) => (y1 - y0 - (c9.length - 1) * py) / sum(c9, value));
    for (const nodes2 of columns) {
      let y4 = y0;
      for (const node of nodes2) {
        node.y0 = y4;
        node.y1 = y4 + node.value * ky2;
        y4 = node.y1 + py;
        for (const link of node.sourceLinks) {
          link.width = link.value * ky2;
        }
      }
      y4 = (y1 - y4 + py) / (nodes2.length + 1);
      for (let i4 = 0; i4 < nodes2.length; ++i4) {
        const node = nodes2[i4];
        node.y0 += y4 * (i4 + 1);
        node.y1 += y4 * (i4 + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max(columns, (c9) => c9.length) - 1));
    initializeNodeBreadths(columns);
    for (let i4 = 0; i4 < iterations; ++i4) {
      const alpha = Math.pow(0.99, i4);
      const beta = Math.max(1 - alpha, (i4 + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i4 = 1, n4 = columns.length; i4 < n4; ++i4) {
      const column = columns[i4];
      for (const target of column) {
        let y4 = 0;
        let w4 = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v4 = value2 * (target.layer - source.layer);
          y4 += targetTop(source, target) * v4;
          w4 += v4;
        }
        if (!(w4 > 0)) continue;
        let dy2 = (y4 / w4 - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n4 = columns.length, i4 = n4 - 2; i4 >= 0; --i4) {
      const column = columns[i4];
      for (const source of column) {
        let y4 = 0;
        let w4 = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v4 = value2 * (target.layer - source.layer);
          y4 += sourceTop(source, target) * v4;
          w4 += v4;
        }
        if (!(w4 > 0)) continue;
        let dy2 = (y4 / w4 - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i4 = nodes2.length >> 1;
    const subject = nodes2[i4];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i4 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i4 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y4, i4, alpha) {
    for (; i4 < nodes2.length; ++i4) {
      const node = nodes2[i4];
      const dy2 = (y4 - node.y0) * alpha;
      if (dy2 > 1e-6) node.y0 += dy2, node.y1 += dy2;
      y4 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y4, i4, alpha) {
    for (; i4 >= 0; --i4) {
      const node = nodes2[i4];
      const dy2 = (node.y1 - y4) * alpha;
      if (dy2 > 1e-6) node.y0 -= dy2, node.y1 -= dy2;
      y4 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y4 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target) break;
      y4 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source) break;
      y4 -= width;
    }
    return y4;
  }
  function sourceTop(source, target) {
    let y4 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source) break;
      y4 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target) break;
      y4 -= width;
    }
    return y4;
  }
  return sankey;
}

// node_modules/@nivo/sankey/dist/nivo-sankey.es.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var import_cloneDeep = __toESM(require_cloneDeep());
function S2() {
  return S2 = Object.assign ? Object.assign.bind() : function(e5) {
    for (var o4 = 1; o4 < arguments.length; o4++) {
      var n4 = arguments[o4];
      for (var t5 in n4) Object.prototype.hasOwnProperty.call(n4, t5) && (e5[t5] = n4[t5]);
    }
    return e5;
  }, S2.apply(this, arguments);
}
var z3 = { container: { display: "flex", alignItems: "center" }, sourceChip: { marginRight: 7 }, targetChip: { marginLeft: 7, marginRight: 7 } };
var E2 = { center, justify, start: left, end: right };
var G = Object.keys(E2);
var j2 = function(e5) {
  return E2[e5];
};
var D = { layout: "horizontal", align: "center", sort: "auto", colors: { scheme: "nivo" }, nodeOpacity: 0.75, nodeHoverOpacity: 1, nodeHoverOthersOpacity: 0.15, nodeThickness: 12, nodeSpacing: 12, nodeInnerPadding: 0, nodeBorderWidth: 1, nodeBorderColor: { from: "color", modifiers: [["darker", 0.5]] }, nodeBorderRadius: 0, linkOpacity: 0.25, linkHoverOpacity: 0.6, linkHoverOthersOpacity: 0.15, linkContract: 0, linkBlendMode: "multiply", enableLinkGradient: false, enableLabels: true, label: "id", labelPosition: "inside", labelPadding: 9, labelOrientation: "horizontal", labelTextColor: { from: "color", modifiers: [["darker", 0.8]] }, isInteractive: true, nodeTooltip: function(e5) {
  var o4 = e5.node;
  return (0, import_jsx_runtime4.jsx)(w, { id: o4.label, enableChip: true, color: o4.color });
}, linkTooltip: function(e5) {
  var o4 = e5.link;
  return (0, import_jsx_runtime4.jsx)(w, { id: (0, import_jsx_runtime4.jsxs)("span", { style: z3.container, children: [(0, import_jsx_runtime4.jsx)(g, { color: o4.source.color, style: z3.sourceChip }), (0, import_jsx_runtime4.jsx)("strong", { children: o4.source.label }), " > ", (0, import_jsx_runtime4.jsx)("strong", { children: o4.target.label }), (0, import_jsx_runtime4.jsx)(g, { color: o4.target.color, style: z3.targetChip }), (0, import_jsx_runtime4.jsx)("strong", { children: o4.formattedValue })] }) });
}, legends: [], layers: ["links", "nodes", "labels", "legends"], role: "img", animate: true, motionConfig: "gentle" };
var V2 = function(e5) {
  return e5.id;
};
var A2 = function(n4) {
  var t5 = n4.data, i4 = n4.valueFormat, r4 = n4.layout, c9 = n4.width, s4 = n4.height, u3 = n4.sort, h2 = n4.align, v4 = n4.colors, p3 = n4.nodeThickness, g3 = n4.nodeSpacing, f3 = n4.nodeInnerPadding, y4 = n4.nodeBorderColor, m4 = n4.label, k4 = n4.labelTextColor, C4 = (0, import_react19.useState)(null), x5 = C4[0], O3 = C4[1], L2 = (0, import_react19.useState)(null), M3 = L2[0], T4 = L2[1], H = (0, import_react19.useMemo)(function() {
    if ("auto" !== u3) return "input" === u3 ? null : "ascending" === u3 ? function(e5, o4) {
      return e5.value - o4.value;
    } : "descending" === u3 ? function(e5, o4) {
      return o4.value - e5.value;
    } : u3;
  }, [u3]), P2 = "input" === u3 ? null : void 0, W2 = (0, import_react19.useMemo)(function() {
    return "function" == typeof h2 ? h2 : j2(h2);
  }, [h2]), N2 = Et(), F2 = pr(v4, "id"), R = We(y4, N2), S3 = Gi(m4), z4 = We(k4, N2), E3 = Dt(i4), G2 = (0, import_react19.useMemo)(function() {
    return function(e5) {
      var o4 = e5.data, n5 = e5.formatValue, t6 = e5.layout, i5 = e5.alignFunction, r5 = e5.sortFunction, l3 = e5.linkSortMode, a4 = e5.nodeThickness, d3 = e5.nodeSpacing, c10 = e5.nodeInnerPadding, s5 = e5.width, u4 = e5.height, h3 = e5.getColor, v5 = e5.getLabel, p4 = Sankey().nodeAlign(i5).nodeSort(r5).linkSort(l3).nodeWidth(a4).nodePadding(d3).size("horizontal" === t6 ? [s5, u4] : [u4, s5]).nodeId(V2), g4 = (0, import_cloneDeep.default)(o4);
      return p4(g4), g4.nodes.forEach(function(e6) {
        if (e6.color = h3(e6), e6.label = v5(e6), e6.formattedValue = n5(e6.value), "horizontal" === t6) e6.x = e6.x0 + c10, e6.y = e6.y0, e6.width = Math.max(e6.x1 - e6.x0 - 2 * c10, 0), e6.height = Math.max(e6.y1 - e6.y0, 0);
        else {
          e6.x = e6.y0, e6.y = e6.x0 + c10, e6.width = Math.max(e6.y1 - e6.y0, 0), e6.height = Math.max(e6.x1 - e6.x0 - 2 * c10, 0);
          var o5 = e6.x0, i6 = e6.x1;
          e6.x0 = e6.y0, e6.x1 = e6.y1, e6.y0 = o5, e6.y1 = i6;
        }
      }), g4.links.forEach(function(e6) {
        e6.formattedValue = n5(e6.value), e6.color = e6.source.color, e6.pos0 = e6.y0, e6.pos1 = e6.y1, e6.thickness = e6.width, delete e6.y0, delete e6.y1, delete e6.width;
      }), g4;
    }({ data: t5, formatValue: E3, layout: r4, alignFunction: W2, sortFunction: H, linkSortMode: P2, nodeThickness: p3, nodeSpacing: g3, nodeInnerPadding: f3, width: c9, height: s4, getColor: F2, getLabel: S3 });
  }, [t5, E3, r4, W2, H, P2, p3, g3, f3, c9, s4, F2, S3]), D2 = G2.nodes, A3 = G2.links, Z2 = (0, import_react19.useMemo)(function() {
    return D2.map(function(e5) {
      return { id: e5.id, label: e5.label, color: e5.color };
    });
  }, [D2]);
  return { nodes: D2, links: A3, legendData: Z2, getNodeBorderColor: R, currentNode: x5, setCurrentNode: O3, currentLink: M3, setCurrentLink: T4, getLabelTextColor: z4 };
};
var Z = function(e5) {
  var o4 = e5.node, i4 = e5.x, r4 = e5.y, l3 = e5.width, a4 = e5.height, d3 = e5.color, s4 = e5.opacity, u3 = e5.borderWidth, h2 = e5.borderColor, v4 = e5.borderRadius, p3 = e5.setCurrent, g3 = e5.isInteractive, f3 = e5.onClick, y4 = e5.tooltip, m4 = Zr(), k4 = m4.animate, b3 = m4.config, C4 = useSpring({ x: i4, y: r4, width: l3, height: a4, opacity: s4, color: d3, config: b3, immediate: !k4 }), x5 = k(), M3 = x5.showTooltipFromEvent, T4 = x5.hideTooltip, w4 = (0, import_react19.useCallback)(function(e6) {
    p3(o4), M3((0, import_react19.createElement)(y4, { node: o4 }), e6, "left");
  }, [p3, o4, M3, y4]), B2 = (0, import_react19.useCallback)(function(e6) {
    M3((0, import_react19.createElement)(y4, { node: o4 }), e6, "left");
  }, [M3, o4, y4]), I = (0, import_react19.useCallback)(function() {
    p3(null), T4();
  }, [p3, T4]), W2 = (0, import_react19.useCallback)(function(e6) {
    null == f3 || f3(o4, e6);
  }, [f3, o4]);
  return (0, import_jsx_runtime4.jsx)(animated.rect, { x: C4.x, y: C4.y, rx: v4, ry: v4, width: C4.width.to(function(e6) {
    return Math.max(e6, 0);
  }), height: C4.height.to(function(e6) {
    return Math.max(e6, 0);
  }), fill: C4.color, fillOpacity: C4.opacity, strokeWidth: u3, stroke: h2, strokeOpacity: s4, onMouseEnter: g3 ? w4 : void 0, onMouseMove: g3 ? B2 : void 0, onMouseLeave: g3 ? I : void 0, onClick: g3 ? W2 : void 0 });
};
var q = function(e5) {
  var o4 = e5.nodes, n4 = e5.nodeOpacity, t5 = e5.nodeHoverOpacity, i4 = e5.nodeHoverOthersOpacity, r4 = e5.borderWidth, l3 = e5.getBorderColor, a4 = e5.borderRadius, d3 = e5.setCurrentNode, c9 = e5.currentNode, s4 = e5.currentLink, u3 = e5.isCurrentNode, h2 = e5.isInteractive, v4 = e5.onClick, p3 = e5.tooltip, g3 = function(e6) {
    return c9 || s4 ? u3(e6) ? t5 : i4 : n4;
  };
  return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: o4.map(function(e6) {
    return (0, import_jsx_runtime4.jsx)(Z, { node: e6, x: e6.x, y: e6.y, width: e6.width, height: e6.height, color: e6.color, opacity: g3(e6), borderWidth: r4, borderColor: l3(e6), borderRadius: a4, setCurrent: d3, isInteractive: h2, onClick: v4, tooltip: p3 }, e6.id);
  }) });
};
var U = function(e5) {
  var o4 = e5.id, n4 = e5.layout, t5 = e5.startColor, i4 = e5.endColor;
  return (0, import_jsx_runtime4.jsxs)("linearGradient", S2({ id: o4, spreadMethod: "pad" }, "horizontal" === n4 ? { x1: "0%", x2: "100%", y1: "0%", y2: "0%" } : { x1: "0%", x2: "0%", y1: "0%", y2: "100%" }, { children: [(0, import_jsx_runtime4.jsx)("stop", { offset: "0%", stopColor: t5 }), (0, import_jsx_runtime4.jsx)("stop", { offset: "100%", stopColor: i4 })] }));
};
var J = function(e5) {
  var o4 = e5.link, i4 = e5.layout, r4 = e5.path, l3 = e5.color, a4 = e5.opacity, d3 = e5.blendMode, u3 = e5.enableGradient, h2 = e5.setCurrent, v4 = e5.tooltip, p3 = e5.isInteractive, g3 = e5.onClick, f3 = o4.source.id + "." + o4.target.id + "." + o4.index, y4 = Zr(), m4 = y4.animate, k4 = y4.config, b3 = $r(r4), C4 = useSpring({ color: l3, opacity: a4, config: k4, immediate: !m4 }), x5 = k(), w4 = x5.showTooltipFromEvent, B2 = x5.hideTooltip, I = (0, import_react19.useCallback)(function(e6) {
    h2(o4), w4((0, import_react19.createElement)(v4, { link: o4 }), e6, "left");
  }, [h2, o4, w4, v4]), W2 = (0, import_react19.useCallback)(function(e6) {
    w4((0, import_react19.createElement)(v4, { link: o4 }), e6, "left");
  }, [w4, o4, v4]), N2 = (0, import_react19.useCallback)(function() {
    h2(null), B2();
  }, [h2, B2]), F2 = (0, import_react19.useCallback)(function(e6) {
    null == g3 || g3(o4, e6);
  }, [g3, o4]);
  return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [u3 && (0, import_jsx_runtime4.jsx)(U, { id: f3, layout: i4, startColor: o4.startColor || o4.source.color, endColor: o4.endColor || o4.target.color }), (0, import_jsx_runtime4.jsx)(animated.path, { fill: u3 ? 'url("#' + encodeURI(f3) + '")' : C4.color, d: b3, fillOpacity: C4.opacity, onMouseEnter: p3 ? I : void 0, onMouseMove: p3 ? W2 : void 0, onMouseLeave: p3 ? N2 : void 0, onClick: p3 ? F2 : void 0, style: { mixBlendMode: d3 } })] });
};
var K = function(e5) {
  var n4 = e5.links, t5 = e5.layout, i4 = e5.linkOpacity, r4 = e5.linkHoverOpacity, l3 = e5.linkHoverOthersOpacity, a4 = e5.linkContract, d3 = e5.linkBlendMode, c9 = e5.enableLinkGradient, s4 = e5.setCurrentLink, u3 = e5.currentLink, h2 = e5.currentNode, v4 = e5.isCurrentLink, p3 = e5.isInteractive, g3 = e5.onClick, f3 = e5.tooltip, y4 = function(e6) {
    return h2 || u3 ? v4(e6) ? r4 : l3 : i4;
  }, m4 = (0, import_react19.useMemo)(function() {
    return "horizontal" === t5 ? (e6 = line_default().curve(monotoneX), function(o4, n5) {
      var t6 = Math.max(1, o4.thickness - 2 * n5) / 2, i5 = 0.12 * (o4.target.x0 - o4.source.x1), r5 = [[o4.source.x1, o4.pos0 - t6], [o4.source.x1 + i5, o4.pos0 - t6], [o4.target.x0 - i5, o4.pos1 - t6], [o4.target.x0, o4.pos1 - t6], [o4.target.x0, o4.pos1 + t6], [o4.target.x0 - i5, o4.pos1 + t6], [o4.source.x1 + i5, o4.pos0 + t6], [o4.source.x1, o4.pos0 + t6], [o4.source.x1, o4.pos0 - t6]];
      return e6(r5) + "Z";
    }) : function() {
      var e7 = line_default().curve(monotoneY);
      return function(o4, n5) {
        var t6 = Math.max(1, o4.thickness - 2 * n5) / 2, i5 = 0.12 * (o4.target.y0 - o4.source.y1), r5 = [[o4.pos0 + t6, o4.source.y1], [o4.pos0 + t6, o4.source.y1 + i5], [o4.pos1 + t6, o4.target.y0 - i5], [o4.pos1 + t6, o4.target.y0], [o4.pos1 - t6, o4.target.y0], [o4.pos1 - t6, o4.target.y0 - i5], [o4.pos0 - t6, o4.source.y1 + i5], [o4.pos0 - t6, o4.source.y1], [o4.pos0 + t6, o4.source.y1]];
        return e7(r5) + "Z";
      };
    }();
    var e6;
  }, [t5]);
  return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: n4.map(function(e6) {
    return (0, import_jsx_runtime4.jsx)(J, { link: e6, layout: t5, path: m4(e6, a4), color: e6.color, opacity: y4(e6), blendMode: d3, enableGradient: c9, setCurrent: s4, isInteractive: p3, onClick: g3, tooltip: f3 }, e6.source.id + "." + e6.target.id + "." + e6.index);
  }) });
};
var Q = function(e5) {
  var o4 = e5.nodes, n4 = e5.layout, t5 = e5.width, i4 = e5.height, r4 = e5.labelPosition, a4 = e5.labelPadding, d3 = e5.labelOrientation, s4 = e5.getLabelTextColor, u3 = Et(), h2 = "vertical" === d3 ? -90 : 0, v4 = o4.map(function(e6) {
    var o5, l3, c9;
    return "horizontal" === n4 ? (l3 = e6.y + e6.height / 2, e6.x < t5 / 2 ? "inside" === r4 ? (o5 = e6.x1 + a4, c9 = "vertical" === d3 ? "middle" : "start") : (o5 = e6.x - a4, c9 = "vertical" === d3 ? "middle" : "end") : "inside" === r4 ? (o5 = e6.x - a4, c9 = "vertical" === d3 ? "middle" : "end") : (o5 = e6.x1 + a4, c9 = "vertical" === d3 ? "middle" : "start")) : "vertical" === n4 && (o5 = e6.x + e6.width / 2, e6.y < i4 / 2 ? "inside" === r4 ? (l3 = e6.y1 + a4, c9 = "vertical" === d3 ? "end" : "middle") : (l3 = e6.y - a4, c9 = "vertical" === d3 ? "start" : "middle") : "inside" === r4 ? (l3 = e6.y - a4, c9 = "vertical" === d3 ? "start" : "middle") : (l3 = e6.y1 + a4, c9 = "vertical" === d3 ? "end" : "middle")), { id: e6.id, label: e6.label, x: o5, y: l3, textAnchor: c9, color: s4(e6) };
  }), p3 = Zr(), g3 = p3.animate, f3 = p3.config, y4 = useSprings(v4.length, v4.map(function(e6) {
    return { transform: "translate(" + e6.x + ", " + e6.y + ") rotate(" + h2 + ")", color: e6.color, config: f3, immediate: !g3 };
  }));
  return (0, import_jsx_runtime4.jsx)(import_jsx_runtime4.Fragment, { children: y4.map(function(e6, o5) {
    var n5 = v4[o5];
    return (0, import_jsx_runtime4.jsx)(animated.text, { dominantBaseline: "central", textAnchor: n5.textAnchor, transform: e6.transform, style: S2({}, u3.labels.text, { fill: e6.color, pointerEvents: "none" }), children: n5.label }, n5.id);
  }) });
};
var X2 = ["isInteractive", "animate", "motionConfig", "theme", "renderWrapper"];
var Y = function(e5) {
  var o4 = e5.data, n4 = e5.valueFormat, l3 = e5.layout, a4 = void 0 === l3 ? D.layout : l3, d3 = e5.sort, c9 = void 0 === d3 ? D.sort : d3, s4 = e5.align, u3 = void 0 === s4 ? D.align : s4, p3 = e5.width, f3 = e5.height, y4 = e5.margin, m4 = e5.colors, k4 = void 0 === m4 ? D.colors : m4, b3 = e5.nodeThickness, C4 = void 0 === b3 ? D.nodeThickness : b3, x5 = e5.nodeSpacing, O3 = void 0 === x5 ? D.nodeThickness : x5, M3 = e5.nodeInnerPadding, T4 = void 0 === M3 ? D.nodeInnerPadding : M3, w4 = e5.nodeBorderColor, B2 = void 0 === w4 ? D.nodeBorderColor : w4, I = e5.nodeOpacity, H = void 0 === I ? D.nodeOpacity : I, P2 = e5.nodeHoverOpacity, W2 = void 0 === P2 ? D.nodeHoverOpacity : P2, N2 = e5.nodeHoverOthersOpacity, F2 = void 0 === N2 ? D.nodeHoverOthersOpacity : N2, R = e5.nodeBorderWidth, z4 = void 0 === R ? D.nodeBorderWidth : R, E3 = e5.nodeBorderRadius, G2 = void 0 === E3 ? D.nodeBorderRadius : E3, j3 = e5.linkOpacity, V3 = void 0 === j3 ? D.linkOpacity : j3, Z2 = e5.linkHoverOpacity, U2 = void 0 === Z2 ? D.linkHoverOpacity : Z2, J2 = e5.linkHoverOthersOpacity, X3 = void 0 === J2 ? D.linkHoverOthersOpacity : J2, Y2 = e5.linkContract, $2 = void 0 === Y2 ? D.linkContract : Y2, _2 = e5.linkBlendMode, ee = void 0 === _2 ? D.linkBlendMode : _2, oe = e5.enableLinkGradient, ne = void 0 === oe ? D.enableLinkGradient : oe, te = e5.enableLabels, ie = void 0 === te ? D.enableLabels : te, re = e5.labelPosition, le = void 0 === re ? D.labelPosition : re, ae = e5.labelPadding, de = void 0 === ae ? D.labelPadding : ae, ce = e5.labelOrientation, se = void 0 === ce ? D.labelOrientation : ce, ue = e5.label, he = void 0 === ue ? D.label : ue, ve = e5.labelTextColor, pe = void 0 === ve ? D.labelTextColor : ve, ge = e5.nodeTooltip, fe = void 0 === ge ? D.nodeTooltip : ge, ye = e5.linkTooltip, me = void 0 === ye ? D.linkTooltip : ye, ke = e5.isInteractive, be = void 0 === ke ? D.isInteractive : ke, Ce2 = e5.onClick, xe = e5.legends, Oe2 = void 0 === xe ? D.legends : xe, Le2 = e5.layers, Me2 = void 0 === Le2 ? D.layers : Le2, Te2 = e5.role, we2 = void 0 === Te2 ? D.role : Te2, Be2 = e5.ariaLabel, Ie = e5.ariaLabelledBy, He2 = e5.ariaDescribedBy, Pe2 = Bt(p3, f3, y4), We2 = Pe2.margin, Ne2 = Pe2.innerWidth, Fe2 = Pe2.innerHeight, Re2 = Pe2.outerWidth, Se2 = Pe2.outerHeight, ze = A2({ data: o4, valueFormat: n4, layout: a4, width: Ne2, height: Fe2, sort: c9, align: u3, colors: k4, nodeThickness: C4, nodeSpacing: O3, nodeInnerPadding: T4, nodeBorderColor: B2, label: he, labelTextColor: pe }), Ee = ze.nodes, Ge2 = ze.links, je2 = ze.legendData, De2 = ze.getNodeBorderColor, Ve2 = ze.currentNode, Ae = ze.setCurrentNode, Ze2 = ze.currentLink, qe2 = ze.setCurrentLink, Ue2 = ze.getLabelTextColor, Je2 = function() {
    return false;
  }, Ke2 = function() {
    return false;
  };
  if (Ze2 && (Je2 = function(e6) {
    var o5 = e6.id;
    return o5 === Ze2.source.id || o5 === Ze2.target.id;
  }, Ke2 = function(e6) {
    var o5 = e6.source, n5 = e6.target;
    return o5.id === Ze2.source.id && n5.id === Ze2.target.id;
  }), Ve2) {
    var Qe3 = [Ve2.id];
    Ge2.filter(function(e6) {
      var o5 = e6.source, n5 = e6.target;
      return o5.id === Ve2.id || n5.id === Ve2.id;
    }).forEach(function(e6) {
      var o5 = e6.source, n5 = e6.target;
      Qe3.push(o5.id), Qe3.push(n5.id);
    }), Qe3 = (0, import_uniq.default)(Qe3), Je2 = function(e6) {
      var o5 = e6.id;
      return Qe3.includes(o5);
    }, Ke2 = function(e6) {
      var o5 = e6.source, n5 = e6.target;
      return o5.id === Ve2.id || n5.id === Ve2.id;
    };
  }
  var Xe2 = { links: Ge2, nodes: Ee, margin: We2, width: p3, height: f3, outerWidth: Re2, outerHeight: Se2 }, Ye2 = { links: null, nodes: null, labels: null, legends: null };
  return Me2.includes("links") && (Ye2.links = (0, import_jsx_runtime4.jsx)(K, { links: Ge2, layout: a4, linkContract: $2, linkOpacity: V3, linkHoverOpacity: U2, linkHoverOthersOpacity: X3, linkBlendMode: ee, enableLinkGradient: ne, setCurrentLink: qe2, currentNode: Ve2, currentLink: Ze2, isCurrentLink: Ke2, isInteractive: be, onClick: Ce2, tooltip: me }, "links")), Me2.includes("nodes") && (Ye2.nodes = (0, import_jsx_runtime4.jsx)(q, { nodes: Ee, nodeOpacity: H, nodeHoverOpacity: W2, nodeHoverOthersOpacity: F2, borderWidth: z4, borderRadius: G2, getBorderColor: De2, setCurrentNode: Ae, currentNode: Ve2, currentLink: Ze2, isCurrentNode: Je2, isInteractive: be, onClick: Ce2, tooltip: fe }, "nodes")), Me2.includes("labels") && ie && (Ye2.labels = (0, import_jsx_runtime4.jsx)(Q, { nodes: Ee, layout: a4, width: Ne2, height: Fe2, labelPosition: le, labelPadding: de, labelOrientation: se, getLabelTextColor: Ue2 }, "labels")), Me2.includes("legends") && (Ye2.legends = (0, import_jsx_runtime4.jsx)(import_react19.Fragment, { children: Oe2.map(function(e6, o5) {
    return (0, import_jsx_runtime4.jsx)(X, S2({}, e6, { containerWidth: Ne2, containerHeight: Fe2, data: je2 }), "legend" + o5);
  }) }, "legends")), (0, import_jsx_runtime4.jsx)(_i, { width: Re2, height: Se2, margin: We2, role: we2, ariaLabel: Be2, ariaLabelledBy: Ie, ariaDescribedBy: He2, children: Me2.map(function(e6, o5) {
    var n5;
    return "function" == typeof e6 ? (0, import_jsx_runtime4.jsx)(import_react19.Fragment, { children: (0, import_react19.createElement)(e6, Xe2) }, o5) : null != (n5 = null == Ye2 ? void 0 : Ye2[e6]) ? n5 : null;
  }) });
};
var $ = function(e5) {
  var o4 = e5.isInteractive, n4 = void 0 === o4 ? D.isInteractive : o4, t5 = e5.animate, i4 = void 0 === t5 ? D.animate : t5, r4 = e5.motionConfig, l3 = void 0 === r4 ? D.motionConfig : r4, a4 = e5.theme, d3 = e5.renderWrapper, c9 = function(e6, o5) {
    if (null == e6) return {};
    var n5, t6, i5 = {}, r5 = Object.keys(e6);
    for (t6 = 0; t6 < r5.length; t6++) n5 = r5[t6], o5.indexOf(n5) >= 0 || (i5[n5] = e6[n5]);
    return i5;
  }(e5, X2);
  return (0, import_jsx_runtime4.jsx)(Ht, { animate: i4, isInteractive: n4, motionConfig: l3, renderWrapper: d3, theme: a4, children: (0, import_jsx_runtime4.jsx)(Y, S2({ isInteractive: n4 }, c9)) });
};
var _ = function(e5) {
  return (0, import_jsx_runtime4.jsx)(Jt, { children: function(o4) {
    var n4 = o4.width, t5 = o4.height;
    return (0, import_jsx_runtime4.jsx)($, S2({ width: n4, height: t5 }, e5));
  } });
};
export {
  _ as ResponsiveSankey,
  $ as Sankey,
  j2 as sankeyAlignmentFromProp,
  G as sankeyAlignmentPropKeys,
  E2 as sankeyAlignmentPropMapping,
  D as svgDefaultProps
};
//# sourceMappingURL=@nivo_sankey.js.map
